
module T_red_black_tree__Color [#"../red_black_tree.rs" 13 0 13 10]
  type t_Color  =
    | C_Red
    | C_Black
  
  function any_l (_ : 'b) : 'a
  
  let rec v_Red (input:t_Color) (ret  )= any
    [ good -> {C_Red  = input} (! ret) | bad -> {C_Red  <> input} (! {false} any) ]
    
  
  let rec v_Black (input:t_Color) (ret  )= any
    [ good -> {C_Black  = input} (! ret) | bad -> {C_Black  <> input} (! {false} any) ]
    
end
module M_red_black_tree__qyi11959472507597060150__clone [#"../red_black_tree.rs" 12 9 12 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree0 = "../red_black_tree.rs" 12 9 12 14
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use T_red_black_tree__Color as Color'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:Color'0.t_Color) (return'  (ret:Color'0.t_Color))= (! bb0
    [ bb0 = any [ br0 -> {self = Color'0.C_Red } (! bb2) | br1 -> {self = Color'0.C_Black } (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- Color'0.C_Black ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- Color'0.C_Red ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : Color'0.t_Color = any_l () | & self : Color'0.t_Color = self ] 
    [ return' (result:Color'0.t_Color)-> {[@expl:postcondition] [%#sred_black_tree0] result = self}
      (! return' {result}) ]
    
end
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module T_red_black_tree__Node [#"../red_black_tree.rs" 19 0 19 17]
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Color as Color'0
  
  type t_Node 'k 'v =
    | C_Node (t_Tree 'k 'v) (Color'0.t_Color) 'k 'v (t_Tree 'k 'v)
  with t_Tree 'k 'v =
    | C_Tree (Option'0.t_Option (t_Node 'k 'v))
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Node < 'k > < 'v > (input:t_Node 'k 'v) (ret  (left:t_Tree 'k 'v) (color:Color'0.t_Color) (key:'k) (val':'v) (right:t_Tree 'k 'v))= any
    [ good (left:t_Tree 'k 'v) (color:Color'0.t_Color) (key:'k) (val':'v) (right:t_Tree 'k 'v)-> {C_Node left color key val' right
      = input}
      (! ret {left} {color} {key} {val'} {right}) ]
    
  
  let rec t_Tree < 'k > < 'v > (input:t_Tree 'k 'v) (ret  (node:Option'0.t_Option (t_Node 'k 'v)))= any
    [ good (node:Option'0.t_Option (t_Node 'k 'v))-> {C_Tree node = input} (! ret {node}) ]
    
  
  function t_Node__left (self : t_Node 'k 'v) : t_Tree 'k 'v =
    match self with
      | C_Node a _ _ _ _ -> a
      end
  
  function t_Node__key (self : t_Node 'k 'v) : 'k =
    match self with
      | C_Node _ _ a _ _ -> a
      end
  
  function t_Node__right (self : t_Node 'k 'v) : t_Tree 'k 'v =
    match self with
      | C_Node _ _ _ _ a -> a
      end
  
  function t_Node__val (self : t_Node 'k 'v) : 'v =
    match self with
      | C_Node _ _ _ a _ -> a
      end
  
  function t_Node__color (self : t_Node 'k 'v) : Color'0.t_Color =
    match self with
      | C_Node _ a _ _ _ -> a
      end
  
  function t_Tree__node (self : t_Tree 'k 'v) : Option'0.t_Option (t_Node 'k 'v) =
    match self with
      | C_Tree a -> a
      end
end
module T_red_black_tree__Tree [#"../red_black_tree.rs" 27 0 27 17]
  use export T_red_black_tree__Node
end
module M_red_black_tree__qyi2476155906044564626__model_acc_has_mapping [#"../red_black_tree.rs" 72 4 76 5] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 70 4 71 93
  let%span span1 = "../red_black_tree.rs" 37 12 41 13
  let%span span2 = "../red_black_tree.rs" 58 12 65 13
  
  use map.Map
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span1] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  constant self  : Tree'0.t_Tree k v
  
  constant accu  : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
  
  constant k  : t_DeepModelTy'0
  
  function model_acc_has_mapping [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
  
  goal vc_model_acc_has_mapping : match self with
    | Tree'0.C_Tree (Option'0.C_None) -> [%#sred_black_tree0] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
    | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> ([%#sred_black_tree0] Map.get (model_acc'0 left accu) k
    = Map.get accu k
    \/ (exists v : v . Map.get (model_acc'0 left accu) k = Option'0.C_Some v /\ has_mapping'0 left k v))
     -> (let _ = model_acc_has_mapping left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in ([%#sred_black_tree0] Map.get (model_acc'0 right accu2) k
    = Map.get accu2 k
    \/ (exists v : v . Map.get (model_acc'0 right accu2) k = Option'0.C_Some v /\ has_mapping'0 right k v))
     -> ([%#sred_black_tree0] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)))
    end
end
module T_core__cmp__Ordering
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function any_l (_ : 'b) : 'a
  
  let rec v_Less (input:t_Ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} (! {false} any) ]
    
  
  let rec v_Equal (input:t_Ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} (! {false} any) ]
    
  
  let rec v_Greater (input:t_Ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} (! {false} any) ]
    
end
module M_red_black_tree__qyi2476155906044564626__has_mapping_model_acc [#"../red_black_tree.rs" 93 4 95 33] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 91 15 91 35
  let%span sred_black_tree1 = "../red_black_tree.rs" 92 4 92 94
  let%span sred_black_tree2 = "../red_black_tree.rs" 70 4 71 93
  let%span span3 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span4 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span5 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span6 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span7 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span8 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span9 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span10 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span16 = "../red_black_tree.rs" 37 12 41 13
  let%span span17 = "../red_black_tree.rs" 58 12 65 13
  let%span span18 = "../red_black_tree.rs" 78 12 86 13
  let%span span19 = "../red_black_tree.rs" 222 12 223 104
  let%span span20 = "../red_black_tree.rs" 242 12 248 13
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span3] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span4] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span5] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span6] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span7] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span8] cmp_log'0 x y
  = o)  -> ([%#span9] cmp_log'0 y z = o)  -> ([%#span10] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span11] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span12] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span13] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span14] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span15] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use map.Map
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span17] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#sred_black_tree2] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span19] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  constant self  : Tree'0.t_Tree k v
  
  constant accu  : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
  
  constant k  : t_DeepModelTy'0
  
  function has_mapping_model_acc [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
  
  goal vc_has_mapping_model_acc : ([%#sred_black_tree0] bst_invariant'0 self)
   -> match self with
    | Tree'0.C_Tree (Option'0.C_None) -> [%#sred_black_tree1] forall v : v . has_mapping'0 self k v
     -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v
    | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> ([%#sred_black_tree0] bst_invariant'0 left)
    /\ (([%#sred_black_tree1] forall v : v . has_mapping'0 left k v
     -> Map.get (model_acc'0 left accu) k = Option'0.C_Some v)
     -> (let _ = has_mapping_model_acc left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in ([%#sred_black_tree0] bst_invariant'0 right)
    /\ (([%#sred_black_tree1] forall v : v . has_mapping'0 right k v
     -> Map.get (model_acc'0 right accu2) k = Option'0.C_Some v)
     -> (let _ = has_mapping_model_acc right accu2 k in ([%#sred_black_tree2] Map.get (model_acc'0 right accu2) k
    = Map.get accu2 k
    \/ (exists v : v . Map.get (model_acc'0 right accu2) k = Option'0.C_Some v /\ has_mapping'0 right k v))
     -> ([%#sred_black_tree1] forall v : v . has_mapping'0 self k v
     -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)))))
    end
end
module M_red_black_tree__qyi2476155906044564626__has_mapping_model [#"../red_black_tree.rs" 114 4 116 33] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 112 15 112 35
  let%span sred_black_tree1 = "../red_black_tree.rs" 113 4 113 80
  let%span sred_black_tree2 = "../red_black_tree.rs" 70 4 71 93
  let%span sred_black_tree3 = "../red_black_tree.rs" 91 15 91 35
  let%span sred_black_tree4 = "../red_black_tree.rs" 92 4 92 94
  let%span span5 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span6 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span7 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span8 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span9 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span10 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span18 = "../red_black_tree.rs" 37 12 41 13
  let%span span19 = "../red_black_tree.rs" 58 12 65 13
  let%span span20 = "../red_black_tree.rs" 78 12 86 13
  let%span span21 = "../red_black_tree.rs" 222 12 223 104
  let%span span22 = "../red_black_tree.rs" 242 12 248 13
  let%span span23 = "../red_black_tree.rs" 98 12 107 13
  let%span span24 = "../red_black_tree.rs" 177 20 177 54
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span5] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span6] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span7] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span8] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span9] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span10] cmp_log'0 x y
  = o)  -> ([%#span11] cmp_log'0 y z = o)  -> ([%#span12] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span13] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span14] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span15] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span16] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span17] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use map.Map
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span19] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#sred_black_tree2] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span21] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span22] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span23] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#sred_black_tree3] bst_invariant'0 self)
   -> ([%#sred_black_tree4] forall v : v . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  use map.Const
  
  function shallow_model'0 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span24] model_acc'0 self (Const.const (Option'0.C_None))
  
  constant self  : Tree'0.t_Tree k v
  
  constant k  : t_DeepModelTy'0
  
  function has_mapping_model [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
  
  goal vc_has_mapping_model : ([%#sred_black_tree0] bst_invariant'0 self)
   -> ([%#sred_black_tree2] Map.get (model_acc'0 self (Const.const (Option'0.C_None))) k
  = Map.get (Const.const (Option'0.C_None)) k
  \/ (exists v : v . Map.get (model_acc'0 self (Const.const (Option'0.C_None))) k = Option'0.C_Some v
  /\ has_mapping'0 self k v))
   -> (let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in ([%#sred_black_tree3] bst_invariant'0 self)
  /\ (([%#sred_black_tree4] forall v : v . has_mapping'0 self k v
   -> Map.get (model_acc'0 self (Const.const (Option'0.C_None))) k = Option'0.C_Some v)
   -> ([%#sred_black_tree1] forall v : v . has_mapping'0 self k v
  = (Map.get (shallow_model'0 self) k = Option'0.C_Some v))))
end
module M_red_black_tree__qyi2476155906044564626__has_mapping_inj [#"../red_black_tree.rs" 129 4 131 33] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 125 15 125 35
  let%span sred_black_tree1 = "../red_black_tree.rs" 126 15 126 38
  let%span sred_black_tree2 = "../red_black_tree.rs" 127 15 127 38
  let%span sred_black_tree3 = "../red_black_tree.rs" 128 14 128 22
  let%span sred_black_tree4 = "../red_black_tree.rs" 112 15 112 35
  let%span sred_black_tree5 = "../red_black_tree.rs" 113 4 113 80
  let%span span6 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span7 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span8 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span9 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span10 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span19 = "../red_black_tree.rs" 58 12 65 13
  let%span span20 = "../red_black_tree.rs" 177 20 177 54
  let%span span21 = "../red_black_tree.rs" 37 12 41 13
  let%span span22 = "../red_black_tree.rs" 70 4 71 93
  let%span span23 = "../red_black_tree.rs" 78 12 86 13
  let%span span24 = "../red_black_tree.rs" 222 12 223 104
  let%span span25 = "../red_black_tree.rs" 242 12 248 13
  let%span span26 = "../red_black_tree.rs" 91 15 91 35
  let%span span27 = "../red_black_tree.rs" 92 4 92 94
  let%span span28 = "../red_black_tree.rs" 98 12 107 13
  let%span span29 = "../red_black_tree.rs" 119 12 119 61
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span6] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span7] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span8] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span9] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span10] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span11] cmp_log'0 x y
  = o)  -> ([%#span12] cmp_log'0 y z = o)  -> ([%#span13] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span14] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span15] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span16] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span17] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span18] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_red_black_tree__Tree as Tree'0
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span19] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'0 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span20] model_acc'0 self (Const.const (Option'0.C_None))
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span21] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span23] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span22] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span24] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span25] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span28] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span26] bst_invariant'0 self)
   -> ([%#span27] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span29] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#sred_black_tree4] bst_invariant'0 self)
   -> ([%#sred_black_tree5] forall v : v . has_mapping'0 self k v
  = (Map.get (shallow_model'0 self) k = Option'0.C_Some v))
  
  constant self  : Tree'0.t_Tree k v
  
  constant k  : t_DeepModelTy'0
  
  constant v1  : v
  
  constant v2  : v
  
  function has_mapping_inj [#"../red_black_tree.rs" 129 4 131 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v1 : v) (v2 : v) : ()
    
  
  goal vc_has_mapping_inj : ([%#sred_black_tree2] has_mapping'0 self k v2)
   -> ([%#sred_black_tree1] has_mapping'0 self k v1)
   -> ([%#sred_black_tree0] bst_invariant'0 self)
   -> ([%#sred_black_tree4] bst_invariant'0 self)
  /\ (([%#sred_black_tree5] forall v : v . has_mapping'0 self k v
  = (Map.get (shallow_model'0 self) k = Option'0.C_Some v))
   -> (let _ = has_mapping_model'0 self k in match Map.get (shallow_model'0 self) k with
    | Option'0.C_None -> [%#sred_black_tree3] v1 = v2
    | Option'0.C_Some _v -> [%#sred_black_tree3] v1 = v2
    end))
end
module M_red_black_tree__qyi17561227306860881838__has_mapping [#"../red_black_tree.rs" 144 4 144 57] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 142 4 143 86
  let%span span1 = "../red_black_tree.rs" 37 12 41 13
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span1] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  constant self  : Node'0.t_Node k v
  
  constant k  : t_DeepModelTy'0
  
  constant v  : v
  
  predicate has_mapping [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
  
  goal vc_has_mapping : if k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) then
    [%#sred_black_tree0] forall node : Node'0.t_Node k v . self = node
     -> ((has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v)
    \/ v = T_red_black_tree__Node.t_Node__val self)
    = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  else
    [%#sred_black_tree0] forall node : Node'0.t_Node k v . self = node
     -> ((has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v)
    \/ false)
    = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
end
module M_red_black_tree__qyi14787627995992352676__resolve_coherence [#"../red_black_tree.rs" 194 4 194 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 192 15 192 39
  let%span sred_black_tree1 = "../red_black_tree.rs" 193 14 193 31
  let%span span2 = "../red_black_tree.rs" 37 12 41 13
  let%span span3 = "../red_black_tree.rs" 185 8 187 9
  let%span span4 = "../red_black_tree.rs" 142 4 143 86
  let%span span5 = "../red_black_tree.rs" 145 8 148 9
  let%span span6 = "../red_black_tree.rs" 201 8 203 9
  let%span span7 = "../../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span span8 = "../../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  
  use T_red_black_tree__Tree as Tree'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'2 (_1 : v)
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'0 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span3] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span5] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span4] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'8 [#"../red_black_tree.rs" 200 4 200 28] (self : Node'0.t_Node k v) =
    [%#span6] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'7 (_1 : Node'0.t_Node k v) =
    resolve'8 _1
  
  predicate resolve'6 (self : Node'0.t_Node k v) =
    [%#span7] resolve'7 self
  
  predicate resolve'5 (_1 : Node'0.t_Node k v) =
    resolve'6 _1
  
  predicate resolve'3 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span8] match self with
      | Option'0.C_Some x -> resolve'5 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option (Node'0.t_Node k v)) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Tree'0.t_Tree k v) =
    match x with
      | Tree'0.C_Tree a -> resolve'1 a
      end
  
  constant self  : Tree'0.t_Tree k v
  
  function resolve_coherence [#"../red_black_tree.rs" 194 4 194 31] (self : Tree'0.t_Tree k v) : ()
  
  goal vc_resolve_coherence : ([%#sred_black_tree0] structural_resolve'0 self)  -> ([%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi16896830124134315792__resolve_coherence [#"../red_black_tree.rs" 210 4 210 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 208 15 208 39
  let%span sred_black_tree1 = "../red_black_tree.rs" 209 14 209 31
  let%span span2 = "../red_black_tree.rs" 37 12 41 13
  let%span span3 = "../red_black_tree.rs" 142 4 143 86
  let%span span4 = "../red_black_tree.rs" 145 8 148 9
  let%span span5 = "../red_black_tree.rs" 201 8 203 9
  let%span span6 = "../red_black_tree.rs" 185 8 187 9
  
  use T_red_black_tree__Node as Node'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'2 (_1 : v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span4] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span3] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'0 [#"../red_black_tree.rs" 200 4 200 28] (self : Node'0.t_Node k v) =
    [%#span5] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Color as Color'0
  
  predicate resolve'4 (_1 : Color'0.t_Color) =
    true
  
  predicate resolve'3 (_1 : k)
  
  predicate resolve'5 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span6] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree k v) =
    resolve'5 _1
  
  predicate structural_resolve'0 (x : Node'0.t_Node k v) =
    match x with
      | Node'0.C_Node a b c d e -> resolve'1 e /\ resolve'2 d /\ resolve'3 c /\ resolve'4 b /\ resolve'1 a
      end
  
  constant self  : Node'0.t_Node k v
  
  function resolve_coherence [#"../red_black_tree.rs" 210 4 210 31] (self : Node'0.t_Node k v) : ()
  
  goal vc_resolve_coherence : ([%#sred_black_tree0] structural_resolve'0 self)  -> ([%#sred_black_tree1] resolve'0 self)
end
module T_red_black_tree__CP [#"../red_black_tree.rs" 255 0 255 7]
  use T_red_black_tree__Color as Color'0
  
  type t_CP  =
    | C_CPL (Color'0.t_Color)
    | C_CPN (Color'0.t_Color) (t_CP) (t_CP)
  
  function any_l (_ : 'b) : 'a
  
  let rec v_CPL (input:t_CP) (ret  (field_0:Color'0.t_Color))= any
    [ good (field_0:Color'0.t_Color)-> {C_CPL field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : Color'0.t_Color [C_CPL field_0 : t_CP] . C_CPL field_0 <> input} (! {false} any) ]
    
  
  let rec v_CPN (input:t_CP) (ret  (field_0:Color'0.t_Color) (field_1:t_CP) (field_2:t_CP))= any
    [ good (field_0:Color'0.t_Color) (field_1:t_CP) (field_2:t_CP)-> {C_CPN field_0 field_1 field_2 = input}
      (! ret {field_0} {field_1} {field_2})
    | bad -> {forall field_0 : Color'0.t_Color, field_1 : t_CP, field_2 : t_CP [C_CPN field_0 field_1 field_2 : t_CP] . C_CPN field_0 field_1 field_2
      <> input}
      (! {false}
      any) ]
    
end
module M_red_black_tree__qyi2476155906044564626__height [#"../red_black_tree.rs" 332 4 332 26] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 331 14 331 25
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Tree as Tree'0
  
  use prelude.prelude.Int
  
  constant self  : Tree'0.t_Tree k v
  
  function height [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int
  
  goal vc_height : match self with
    | Tree'0.C_Tree (Option'0.C_None) -> [%#sred_black_tree0] 0 >= 0
    | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
      | Color'0.C_Red -> ([%#sred_black_tree0] height left >= 0)  -> ([%#sred_black_tree0] height left >= 0)
      | Color'0.C_Black -> ([%#sred_black_tree0] height left >= 0)  -> ([%#sred_black_tree0] height left + 1 >= 0)
      end
    end
end
module M_red_black_tree__qyi17561227306860881838__height [#"../red_black_tree.rs" 364 4 364 26] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 362 4 363 77
  let%span sred_black_tree1 = "../red_black_tree.rs" 331 14 331 25
  let%span span2 = "../red_black_tree.rs" 334 12 342 13
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Color as Color'0
  
  use prelude.prelude.Int
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Tree as Tree'0
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#sred_black_tree1] height'0 self >= 0
  
  constant self  : Node'0.t_Node k v
  
  function height [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int
  
  goal vc_height : match T_red_black_tree__Node.t_Node__color self with
    | Color'0.C_Red -> ([%#sred_black_tree1] height'0 (T_red_black_tree__Node.t_Node__left self) >= 0)
     -> ([%#sred_black_tree0] forall node : Node'0.t_Node k v . self = node
     -> height'0 (T_red_black_tree__Node.t_Node__left self) = height'0 (Tree'0.C_Tree (Option'0.C_Some node)))
    | Color'0.C_Black -> ([%#sred_black_tree1] height'0 (T_red_black_tree__Node.t_Node__left self) >= 0)
     -> ([%#sred_black_tree0] forall node : Node'0.t_Node k v . self = node
     -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1 = height'0 (Tree'0.C_Tree (Option'0.C_Some node)))
    end
end
module T_alloc__alloc__Global
  type t_Global  =
    | C_Global
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Global (input:t_Global) (ret  )= any [ good -> {C_Global  = input} (! ret) ] 
end
module M_red_black_tree__qyi2476155906044564626__is_red [#"../red_black_tree.rs" 419 4 419 28] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 422 17 422 22
  let%span sred_black_tree1 = "../red_black_tree.rs" 421 49 421 53
  let%span sred_black_tree2 = "../red_black_tree.rs" 419 15 419 19
  let%span sred_black_tree3 = "../red_black_tree.rs" 418 14 418 45
  let%span span4 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span6 = "../red_black_tree.rs" 294 12 297 13
  
  predicate invariant'3 (self : v)
  
  predicate inv'6 (_1 : v)
  
  axiom inv'6 : forall x : v [inv'6 x] . inv'6 x  -> invariant'3 x
  
  predicate invariant'2 (self : k)
  
  predicate inv'5 (_1 : k)
  
  axiom inv'5 : forall x : k [inv'5 x] . inv'5 x  -> invariant'2 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'1 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node k v)
  
  axiom inv'4 [@rewrite] : forall x : Node'0.t_Node k v [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'1 left /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'1 (self : Node'0.t_Node k v) =
    [%#span4] inv'4 self
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv'1 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'1 x] . inv'1 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Tree'0.t_Tree k v) =
    [%#span5] inv'1 self
  
  predicate inv'0 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'0 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span6] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec is_red (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[%#sred_black_tree2] inv'0 self}
    (! bb0
    [ bb0 = Tree'0.t_Tree <k> <v> {self}
        (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
          any
          [ br0 -> {rnode'0 = Option'0.C_None } (! bb6)
          | br1 (a:Node'0.t_Node k v)-> {rnode'0 = Option'0.C_Some a} (! bb2) ]
          )
    | bb6 = bb1
    | bb2 = Tree'0.t_Tree <k> <v> {self}
        (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
          Option'0.v_Some <Node'0.t_Node k v> {rnode'0}
            (fun (r0'0:Node'0.t_Node k v) ->
              Node'0.t_Node <k> <v> {r0'0}
                (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                  any [ br0 -> {rcolor'0 = Color'0.C_Red } (! bb3) | br1 -> {rcolor'0 = Color'0.C_Black } (! bb1) ] )))
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree0] false ] s1 | s1 = bb5 ] 
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree1] true ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : bool = any_l () | & self : Tree'0.t_Tree k v = self ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sred_black_tree3] result = (color'0 self = Color'0.C_Red)}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__rotate_right [#"../red_black_tree.rs" 443 4 443 30] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 444 23 444 41
  let%span sred_black_tree1 = "../red_black_tree.rs" 472 8 472 90
  let%span sred_black_tree2 = "../red_black_tree.rs" 431 15 431 43
  let%span sred_black_tree3 = "../red_black_tree.rs" 432 15 432 42
  let%span sred_black_tree4 = "../red_black_tree.rs" 443 25 443 29
  let%span sred_black_tree5 = "../red_black_tree.rs" 433 14 433 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 434 14 434 42
  let%span sred_black_tree7 = "../red_black_tree.rs" 435 14 435 50
  let%span sred_black_tree8 = "../red_black_tree.rs" 436 14 436 65
  let%span sred_black_tree9 = "../red_black_tree.rs" 437 14 437 42
  let%span sred_black_tree10 = "../red_black_tree.rs" 438 14 438 44
  let%span sred_black_tree11 = "../red_black_tree.rs" 439 4 442 36
  let%span span12 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span26 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span27 = "../red_black_tree.rs" 331 14 331 25
  let%span span28 = "../red_black_tree.rs" 334 12 342 13
  let%span span29 = "../red_black_tree.rs" 362 4 363 77
  let%span span30 = "../red_black_tree.rs" 366 12 369 13
  let%span span31 = "../red_black_tree.rs" 37 12 41 13
  let%span span32 = "../red_black_tree.rs" 142 4 143 86
  let%span span33 = "../red_black_tree.rs" 145 8 148 9
  let%span span34 = "../red_black_tree.rs" 153 8 155 9
  let%span span35 = "../red_black_tree.rs" 294 12 297 13
  let%span span36 = "../red_black_tree.rs" 375 20 375 61
  let%span span37 = "../red_black_tree.rs" 349 12 355 13
  let%span span38 = "../red_black_tree.rs" 380 8 380 115
  let%span span39 = "../red_black_tree.rs" 222 12 223 104
  let%span span40 = "../red_black_tree.rs" 242 12 248 13
  let%span span41 = "../red_black_tree.rs" 229 8 231 9
  let%span span42 = "../red_black_tree.rs" 410 12 410 59
  let%span span43 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span44 = "../red_black_tree.rs" 185 8 187 9
  let%span span45 = "" 0 0 0 0
  let%span span46 = "" 0 0 0 0
  let%span span47 = "../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span span48 = "../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span span49 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span50 = "" 0 0 0 0
  let%span span51 = "" 0 0 0 0
  let%span span52 = "../../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span span53 = "" 0 0 0 0
  let%span span54 = "../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span span55 = "../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span span56 = "" 0 0 0 0
  
  use T_red_black_tree__Color as Color'0
  
  predicate inv'11 (_1 : Color'0.t_Color)
  
  axiom inv'11 [@rewrite] : forall x : Color'0.t_Color [inv'11 x] . inv'11 x = true
  
  predicate invariant'7 (self : v)
  
  predicate inv'10 (_1 : v)
  
  axiom inv'10 : forall x : v [inv'10 x] . inv'10 x  -> invariant'7 x
  
  predicate invariant'6 (self : k)
  
  predicate inv'9 (_1 : k)
  
  axiom inv'9 : forall x : k [inv'9 x] . inv'9 x  -> invariant'6 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'5 (self : borrowed (Color'0.t_Color)) =
    [%#span12] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'8 (_1 : borrowed (Color'0.t_Color))
  
  axiom inv'8 [@rewrite] : forall x : borrowed (Color'0.t_Color) [inv'8 x] . inv'8 x = true
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span13] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span14] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span15] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span18] cmp_log'0 x y
  = o)  -> ([%#span19] cmp_log'0 y z = o)  -> ([%#span20] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span21] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span24] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span25] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node k v)
  
  predicate invariant'4 (self : borrowed (Node'0.t_Node k v)) =
    [%#span12] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'5 (_1 : Node'0.t_Node k v)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span12] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'6 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'6 x] . inv'6 x = invariant'3 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span26] inv'4 self
  
  axiom inv'5 [@rewrite] : forall x : Node'0.t_Node k v [inv'5 x] . inv'5 x = invariant'2 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'4 [@rewrite] : forall x : Node'0.t_Node k v [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'9 key /\ inv'10 val' /\ inv'2 right
    end
  
  predicate invariant'1 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span12] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'3 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'2 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span12] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use prelude.prelude.Int
  
  function height'1 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span28] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree k v . [%#span27] height'1 self >= 0
  
  function height'0 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span30] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node k v . [%#span29] forall node : Node'0.t_Node k v . self = node
   -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span33] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span32] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span34] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v = has_mapping'1 o k v
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span35] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span36] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span37] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span38] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span39] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span41] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span42] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'11 (self : borrowed (Node'0.t_Node k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'11 _1
  
  predicate resolve'12 (_1 : v)
  
  predicate resolve'10 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span44] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'12 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree k v) =
    resolve'10 _1
  
  use prelude.prelude.Snapshot
  
  predicate resolve'9 (self : borrowed (Color'0.t_Color)) =
    [%#span43] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Color'0.t_Color)) =
    resolve'9 _1
  
  let rec swap'2 (x:borrowed (Color'0.t_Color)) (y:borrowed (Color'0.t_Color)) (return'  (ret:()))= {[@expl:precondition] [%#span46] inv'8 y}
    {[@expl:precondition] [%#span45] inv'8 x}
    any
    [ return' (result:())-> {[%#span48] y.final = x.current} {[%#span47] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Node'0.t_Node k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'8 _1
  
  let rec swap'1 (x:borrowed (Node'0.t_Node k v)) (y:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span46] inv'7 y}
    {[@expl:precondition] [%#span45] inv'7 x}
    any
    [ return' (result:())-> {[%#span48] y.final = x.current} {[%#span47] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'7 _1
  
  let rec swap'0 (x:borrowed (Tree'0.t_Tree k v)) (y:borrowed (Tree'0.t_Tree k v)) (return'  (ret:()))= {[@expl:precondition] [%#span46] inv'3 y}
    {[@expl:precondition] [%#span45] inv'3 x}
    any
    [ return' (result:())-> {[%#span48] y.final = x.current} {[%#span47] x.final = y.current} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span50] inv'0 self}
    {[@expl:precondition] [%#span49] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span51] inv'5 result}
      {[%#span49] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span43] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'6 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span52] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span53] inv'1 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span56] inv'0 result}
      {[%#span55] is_default'0 dest.final}
      {[%#span54] result = dest.current}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_right (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[%#sred_black_tree4] inv'7 self}
    {[%#sred_black_tree3] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[%#sred_black_tree2] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_16 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = {inv'0 _16.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node k v)> {_16.current} {Borrow.get_id _16}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_16 <- { _16 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_15} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':Node'0.t_Node k v) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'2 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_19 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = {inv'2 _19.current}
        Borrow.borrow_final <Tree'0.t_Tree k v> {_19.current} {Borrow.get_id _19}
          (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
             [ &_18 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_19 <- { _19 with current = _ret'.final ; } ] 
            s2)
      | s2 = Node'0.t_Node <k> <v> {x}
          (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
            {inv'2 rright'1}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'1}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_21 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &x <- Node'0.C_Node rleft'1 rcolor'1 rkey'1 rval'1 _ret'.final ] 
                s3))
      | s3 = {inv'2 _21.current}
        Borrow.borrow_final <Tree'0.t_Tree k v> {_21.current} {Borrow.get_id _21}
          (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
             [ &_20 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_21 <- { _21 with current = _ret'.final ; } ] 
            s4)
      | s4 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s5)
      | s5 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'3 _21} s1
      | s1 = -{resolve'1 _21}- s2
      | s2 = {[@expl:type invariant] inv'3 _19} s3
      | s3 = -{resolve'1 _19}- s4
      | s4 = {inv'4 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_23 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s5)
      | s5 = {inv'5 x}
        Borrow.borrow_mut <Node'0.t_Node k v> {x}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_25 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &x <- _ret'.final ] 
            s6)
      | s6 = {inv'4 _25.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_25.current} {Borrow.get_id _25}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_24 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_25 <- { _25 with current = _ret'.final ; } ] 
            s7)
      | s7 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_28 <- _ret' ] 
                 [ &self <- { self with current = Node'0.C_Node rleft'0 _ret'.final rkey'0 rval'0 rright'0 ; } ] 
                s3))
      | s3 = Borrow.borrow_final <Color'0.t_Color> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_27 <- _ret' ] 
             [ &_28 <- { _28 with current = _ret'.final ; } ] 
            s4)
      | s4 = Node'0.t_Node <k> <v> {x}
          (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
            Borrow.borrow_mut <Color'0.t_Color> {rcolor'1}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_30 <- _ret' ] 
                 [ &x <- Node'0.C_Node rleft'1 _ret'.final rkey'1 rval'1 rright'1 ] 
                s5))
      | s5 = Borrow.borrow_final <Color'0.t_Color> {_30.current} {Borrow.get_id _30}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_29 <- _ret' ] 
             [ &_30 <- { _30 with current = _ret'.final ; } ] 
            s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = -{resolve'3 _30}- s1
      | s1 = -{resolve'3 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree1] has_mapping'0 (T_red_black_tree__Node.t_Node__left (Snapshot.inner old_self).current) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (T_red_black_tree__Node.t_Node__val self.current)}
        s3
      | s3 =  [ &_34 <- Option'0.C_Some x ] s4
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 =  [ &_33 <- Tree'0.C_Tree _34 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = Node'0.C_Node _ _ _ _ x'0} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = Node'0.C_Node _ _ _ _ x'1} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _33 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'5 self}- s5
      | s5 = bb11 ]
      
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (Node'0.t_Node k v)) = any_l ()
    | & x : Node'0.t_Node k v = any_l ()
    | & _14 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _16 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _17 : () = any_l ()
    | & _18 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _19 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _20 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _21 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _22 : () = any_l ()
    | & _23 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _24 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _25 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _26 : () = any_l ()
    | & _27 : borrowed (Color'0.t_Color) = any_l ()
    | & _28 : borrowed (Color'0.t_Color) = any_l ()
    | & _29 : borrowed (Color'0.t_Color) = any_l ()
    | & _30 : borrowed (Color'0.t_Color) = any_l ()
    | & _33 : Tree'0.t_Tree k v = any_l ()
    | & _34 : Option'0.t_Option (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree11] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[@expl:postcondition] [%#sred_black_tree10] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 (T_red_black_tree__Node.t_Node__right self.final)
      = Color'0.C_Red}
      {[@expl:postcondition] [%#sred_black_tree8] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[@expl:postcondition] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__rotate_left [#"../red_black_tree.rs" 493 4 493 29] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 494 23 494 41
  let%span sred_black_tree1 = "../red_black_tree.rs" 499 8 499 91
  let%span sred_black_tree2 = "../red_black_tree.rs" 481 15 481 43
  let%span sred_black_tree3 = "../red_black_tree.rs" 482 15 482 43
  let%span sred_black_tree4 = "../red_black_tree.rs" 493 24 493 28
  let%span sred_black_tree5 = "../red_black_tree.rs" 483 14 483 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 484 14 484 42
  let%span sred_black_tree7 = "../red_black_tree.rs" 485 14 485 50
  let%span sred_black_tree8 = "../red_black_tree.rs" 486 14 486 65
  let%span sred_black_tree9 = "../red_black_tree.rs" 487 14 487 41
  let%span sred_black_tree10 = "../red_black_tree.rs" 488 14 488 44
  let%span sred_black_tree11 = "../red_black_tree.rs" 489 4 492 36
  let%span span12 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span26 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span27 = "../red_black_tree.rs" 331 14 331 25
  let%span span28 = "../red_black_tree.rs" 334 12 342 13
  let%span span29 = "../red_black_tree.rs" 362 4 363 77
  let%span span30 = "../red_black_tree.rs" 366 12 369 13
  let%span span31 = "../red_black_tree.rs" 37 12 41 13
  let%span span32 = "../red_black_tree.rs" 142 4 143 86
  let%span span33 = "../red_black_tree.rs" 145 8 148 9
  let%span span34 = "../red_black_tree.rs" 153 8 155 9
  let%span span35 = "../red_black_tree.rs" 294 12 297 13
  let%span span36 = "../red_black_tree.rs" 375 20 375 61
  let%span span37 = "../red_black_tree.rs" 349 12 355 13
  let%span span38 = "../red_black_tree.rs" 380 8 380 115
  let%span span39 = "../red_black_tree.rs" 222 12 223 104
  let%span span40 = "../red_black_tree.rs" 242 12 248 13
  let%span span41 = "../red_black_tree.rs" 229 8 231 9
  let%span span42 = "../red_black_tree.rs" 410 12 410 59
  let%span span43 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span44 = "../red_black_tree.rs" 185 8 187 9
  let%span span45 = "" 0 0 0 0
  let%span span46 = "" 0 0 0 0
  let%span span47 = "../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span span48 = "../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span span49 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span50 = "" 0 0 0 0
  let%span span51 = "" 0 0 0 0
  let%span span52 = "../../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span span53 = "" 0 0 0 0
  let%span span54 = "../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span span55 = "../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span span56 = "" 0 0 0 0
  
  use T_red_black_tree__Color as Color'0
  
  predicate inv'11 (_1 : Color'0.t_Color)
  
  axiom inv'11 [@rewrite] : forall x : Color'0.t_Color [inv'11 x] . inv'11 x = true
  
  predicate invariant'7 (self : v)
  
  predicate inv'10 (_1 : v)
  
  axiom inv'10 : forall x : v [inv'10 x] . inv'10 x  -> invariant'7 x
  
  predicate invariant'6 (self : k)
  
  predicate inv'9 (_1 : k)
  
  axiom inv'9 : forall x : k [inv'9 x] . inv'9 x  -> invariant'6 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'5 (self : borrowed (Color'0.t_Color)) =
    [%#span12] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'8 (_1 : borrowed (Color'0.t_Color))
  
  axiom inv'8 [@rewrite] : forall x : borrowed (Color'0.t_Color) [inv'8 x] . inv'8 x = true
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span13] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span14] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span15] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span18] cmp_log'0 x y
  = o)  -> ([%#span19] cmp_log'0 y z = o)  -> ([%#span20] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span21] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span24] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span25] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node k v)
  
  predicate invariant'4 (self : borrowed (Node'0.t_Node k v)) =
    [%#span12] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'5 (_1 : Node'0.t_Node k v)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span12] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'6 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'6 x] . inv'6 x = invariant'3 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span26] inv'4 self
  
  axiom inv'5 [@rewrite] : forall x : Node'0.t_Node k v [inv'5 x] . inv'5 x = invariant'2 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'4 [@rewrite] : forall x : Node'0.t_Node k v [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'9 key /\ inv'10 val' /\ inv'2 right
    end
  
  predicate invariant'1 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span12] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'3 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'2 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span12] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use prelude.prelude.Int
  
  function height'1 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span28] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree k v . [%#span27] height'1 self >= 0
  
  function height'0 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span30] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node k v . [%#span29] forall node : Node'0.t_Node k v . self = node
   -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span33] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span32] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span34] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v = has_mapping'1 o k v
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span35] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span36] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span37] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span38] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span39] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span41] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span42] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'11 (self : borrowed (Node'0.t_Node k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'11 _1
  
  predicate resolve'12 (_1 : v)
  
  predicate resolve'10 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span44] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'12 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree k v) =
    resolve'10 _1
  
  use prelude.prelude.Snapshot
  
  predicate resolve'9 (self : borrowed (Color'0.t_Color)) =
    [%#span43] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Color'0.t_Color)) =
    resolve'9 _1
  
  let rec swap'2 (x:borrowed (Color'0.t_Color)) (y:borrowed (Color'0.t_Color)) (return'  (ret:()))= {[@expl:precondition] [%#span46] inv'8 y}
    {[@expl:precondition] [%#span45] inv'8 x}
    any
    [ return' (result:())-> {[%#span48] y.final = x.current} {[%#span47] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Node'0.t_Node k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'8 _1
  
  let rec swap'1 (x:borrowed (Node'0.t_Node k v)) (y:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span46] inv'7 y}
    {[@expl:precondition] [%#span45] inv'7 x}
    any
    [ return' (result:())-> {[%#span48] y.final = x.current} {[%#span47] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'7 _1
  
  let rec swap'0 (x:borrowed (Tree'0.t_Tree k v)) (y:borrowed (Tree'0.t_Tree k v)) (return'  (ret:()))= {[@expl:precondition] [%#span46] inv'3 y}
    {[@expl:precondition] [%#span45] inv'3 x}
    any
    [ return' (result:())-> {[%#span48] y.final = x.current} {[%#span47] x.final = y.current} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span50] inv'0 self}
    {[@expl:precondition] [%#span49] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span51] inv'5 result}
      {[%#span49] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span43] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'6 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span52] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span53] inv'1 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span56] inv'0 result}
      {[%#span55] is_default'0 dest.final}
      {[%#span54] result = dest.current}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_left (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[%#sred_black_tree4] inv'7 self}
    {[%#sred_black_tree3] color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red}
    {[%#sred_black_tree2] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_16 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = {inv'0 _16.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node k v)> {_16.current} {Borrow.get_id _16}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_16 <- { _16 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_15} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':Node'0.t_Node k v) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'2 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_19 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = {inv'2 _19.current}
        Borrow.borrow_final <Tree'0.t_Tree k v> {_19.current} {Borrow.get_id _19}
          (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
             [ &_18 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_19 <- { _19 with current = _ret'.final ; } ] 
            s2)
      | s2 = Node'0.t_Node <k> <v> {x}
          (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
            {inv'2 rleft'1}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rleft'1}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_21 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &x <- Node'0.C_Node _ret'.final rcolor'1 rkey'1 rval'1 rright'1 ] 
                s3))
      | s3 = {inv'2 _21.current}
        Borrow.borrow_final <Tree'0.t_Tree k v> {_21.current} {Borrow.get_id _21}
          (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
             [ &_20 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_21 <- { _21 with current = _ret'.final ; } ] 
            s4)
      | s4 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s5)
      | s5 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'3 _21} s1
      | s1 = -{resolve'1 _21}- s2
      | s2 = {[@expl:type invariant] inv'3 _19} s3
      | s3 = -{resolve'1 _19}- s4
      | s4 = {inv'4 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_23 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s5)
      | s5 = {inv'5 x}
        Borrow.borrow_mut <Node'0.t_Node k v> {x}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_25 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &x <- _ret'.final ] 
            s6)
      | s6 = {inv'4 _25.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_25.current} {Borrow.get_id _25}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_24 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_25 <- { _25 with current = _ret'.final ; } ] 
            s7)
      | s7 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_28 <- _ret' ] 
                 [ &self <- { self with current = Node'0.C_Node rleft'0 _ret'.final rkey'0 rval'0 rright'0 ; } ] 
                s3))
      | s3 = Borrow.borrow_final <Color'0.t_Color> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_27 <- _ret' ] 
             [ &_28 <- { _28 with current = _ret'.final ; } ] 
            s4)
      | s4 = Node'0.t_Node <k> <v> {x}
          (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
            Borrow.borrow_mut <Color'0.t_Color> {rcolor'1}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_30 <- _ret' ] 
                 [ &x <- Node'0.C_Node rleft'1 _ret'.final rkey'1 rval'1 rright'1 ] 
                s5))
      | s5 = Borrow.borrow_final <Color'0.t_Color> {_30.current} {Borrow.get_id _30}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_29 <- _ret' ] 
             [ &_30 <- { _30 with current = _ret'.final ; } ] 
            s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = -{resolve'3 _30}- s1
      | s1 = -{resolve'3 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree1] has_mapping'0 (T_red_black_tree__Node.t_Node__right (Snapshot.inner old_self).current) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (T_red_black_tree__Node.t_Node__val self.current)}
        s3
      | s3 =  [ &_34 <- Option'0.C_Some x ] s4
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 =  [ &_33 <- Tree'0.C_Tree _34 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = Node'0.C_Node x'0 _ _ _ _} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = Node'0.C_Node x'1 _ _ _ _} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &self <- { self with current = Node'0.C_Node _33 rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'5 self}- s5
      | s5 = bb11 ]
      
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (Node'0.t_Node k v)) = any_l ()
    | & x : Node'0.t_Node k v = any_l ()
    | & _14 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _16 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _17 : () = any_l ()
    | & _18 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _19 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _20 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _21 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _22 : () = any_l ()
    | & _23 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _24 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _25 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _26 : () = any_l ()
    | & _27 : borrowed (Color'0.t_Color) = any_l ()
    | & _28 : borrowed (Color'0.t_Color) = any_l ()
    | & _29 : borrowed (Color'0.t_Color) = any_l ()
    | & _30 : borrowed (Color'0.t_Color) = any_l ()
    | & _33 : Tree'0.t_Tree k v = any_l ()
    | & _34 : Option'0.t_Option (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree11] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l
      /\ (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.final)
      = (T_red_black_tree__Node.t_Node__left self.current, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      /\ T_red_black_tree__Node.t_Node__key l = T_red_black_tree__Node.t_Node__key self.current}
      {[@expl:postcondition] [%#sred_black_tree10] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 (T_red_black_tree__Node.t_Node__left self.final)
      = Color'0.C_Red}
      {[@expl:postcondition] [%#sred_black_tree8] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final))}
      {[@expl:postcondition] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__flip_colors [#"../red_black_tree.rs" 517 4 517 29] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 503 15 503 43
  let%span sred_black_tree1 = "../red_black_tree.rs" 504 15 504 40
  let%span sred_black_tree2 = "../red_black_tree.rs" 505 15 505 41
  let%span sred_black_tree3 = "../red_black_tree.rs" 506 15 506 60
  let%span sred_black_tree4 = "../red_black_tree.rs" 517 24 517 28
  let%span sred_black_tree5 = "../red_black_tree.rs" 507 14 507 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 508 14 508 50
  let%span sred_black_tree7 = "../red_black_tree.rs" 509 14 509 42
  let%span sred_black_tree8 = "../red_black_tree.rs" 510 14 510 40
  let%span sred_black_tree9 = "../red_black_tree.rs" 511 4 513 70
  let%span sred_black_tree10 = "../red_black_tree.rs" 514 4 516 90
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span24 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span25 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span26 = "../red_black_tree.rs" 37 12 41 13
  let%span span27 = "../red_black_tree.rs" 142 4 143 86
  let%span span28 = "../red_black_tree.rs" 145 8 148 9
  let%span span29 = "../red_black_tree.rs" 153 8 155 9
  let%span span30 = "../red_black_tree.rs" 331 14 331 25
  let%span span31 = "../red_black_tree.rs" 334 12 342 13
  let%span span32 = "../red_black_tree.rs" 362 4 363 77
  let%span span33 = "../red_black_tree.rs" 366 12 369 13
  let%span span34 = "../red_black_tree.rs" 294 12 297 13
  let%span span35 = "../red_black_tree.rs" 375 20 375 61
  let%span span36 = "../red_black_tree.rs" 349 12 355 13
  let%span span37 = "../red_black_tree.rs" 380 8 380 115
  let%span span38 = "../red_black_tree.rs" 222 12 223 104
  let%span span39 = "../red_black_tree.rs" 242 12 248 13
  let%span span40 = "../red_black_tree.rs" 229 8 231 9
  let%span span41 = "../red_black_tree.rs" 410 12 410 59
  let%span span42 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span43 = "" 0 0 0 0
  let%span span44 = "" 0 0 0 0
  let%span span45 = "../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span span46 = "../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span span47 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span48 = "" 0 0 0 0
  let%span span49 = "" 0 0 0 0
  let%span span50 = "" 0 0 0 0
  let%span span51 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span52 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span53 = "" 0 0 0 0
  
  predicate invariant'7 (self : v)
  
  predicate inv'11 (_1 : v)
  
  axiom inv'11 : forall x : v [inv'11 x] . inv'11 x  -> invariant'7 x
  
  predicate invariant'6 (self : k)
  
  predicate inv'10 (_1 : k)
  
  axiom inv'10 : forall x : k [inv'10 x] . inv'10 x  -> invariant'6 x
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'9 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'9 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'9 x] . inv'9 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  use T_red_black_tree__Color as Color'0
  
  predicate inv'8 (_1 : Color'0.t_Color)
  
  axiom inv'8 [@rewrite] : forall x : Color'0.t_Color [inv'8 x] . inv'8 x = true
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span11] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span12] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span13] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span14] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span15] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span16] cmp_log'0 x y
  = o)  -> ([%#span17] cmp_log'0 y z = o)  -> ([%#span18] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span19] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span20] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span21] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'7 (_1 : Node'0.t_Node k v)
  
  axiom inv'7 [@rewrite] : forall x : Node'0.t_Node k v [inv'7 x] . inv'7 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'9 left /\ inv'10 key /\ inv'11 val' /\ inv'9 right
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'4 (self : Node'0.t_Node k v) =
    [%#span24] inv'7 self
  
  predicate inv'6 (_1 : Node'0.t_Node k v)
  
  axiom inv'6 [@rewrite] : forall x : Node'0.t_Node k v [inv'6 x] . inv'6 x = invariant'4 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : borrowed (Color'0.t_Color)) =
    [%#span25] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'5 (_1 : borrowed (Color'0.t_Color))
  
  axiom inv'5 [@rewrite] : forall x : borrowed (Color'0.t_Color) [inv'5 x] . inv'5 x = true
  
  predicate inv'1 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'4 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'4 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  predicate invariant'2 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'3 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'3 x] . inv'3 x
  = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span25] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node k v)) =
    [%#span25] inv'6 self.current /\ inv'6 self.final
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span26] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span28] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span27] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span29] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v = has_mapping'0 o k v
  
  use prelude.prelude.Int
  
  function height'1 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree k v . [%#span30] height'1 self >= 0
  
  function height'0 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span33] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node k v . [%#span32] forall node : Node'0.t_Node k v . self = node
   -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span34] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span35] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span36] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span37] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span38] (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span39] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span40] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span41] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span42] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'5 _1
  
  predicate resolve'4 (self : borrowed (Color'0.t_Color)) =
    [%#span42] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Color'0.t_Color)) =
    resolve'4 _1
  
  let rec swap'0 (x:borrowed (Color'0.t_Color)) (y:borrowed (Color'0.t_Color)) (return'  (ret:()))= {[@expl:precondition] [%#span44] inv'5 y}
    {[@expl:precondition] [%#span43] inv'5 x}
    any
    [ return' (result:())-> {[%#span46] y.final = x.current} {[%#span45] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span42] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'3 _1
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span48] inv'4 self}
    {[@expl:precondition] [%#span47] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span49] inv'1 result}
      {[%#span47] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span50] inv'3 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span53] inv'4 result}
      {[%#span52] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span51] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec flip_colors (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[%#sred_black_tree4] inv'2 self}
    {[%#sred_black_tree3] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[%#sred_black_tree2] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[%#sred_black_tree1] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_15 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_15} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Node'0.t_Node <k> <v> {_13.current}
              (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
                 [ &_13 <- { _13 with current = Node'0.C_Node rleft'1 rcolor'0 rkey'1 rval'1 rright'1 ; } ] 
                s1))
      | s1 = {[@expl:type invariant] inv'1 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'2:Tree'0.t_Tree k v) (rcolor'2:Color'0.t_Color) (rkey'2:k) (rval'2:v) (rright'2:Tree'0.t_Tree k v) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'2} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_18 <- _ret' ] 
                 [ &self <- { self with current = Node'0.C_Node rleft'2 _ret'.final rkey'2 rval'2 rright'2 ; } ] 
                s4))
      | s4 = Borrow.borrow_final <Color'0.t_Color> {_18.current} {Borrow.get_id _18}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_17 <- _ret' ] 
             [ &_18 <- { _18 with current = _ret'.final ; } ] 
            s5)
      | s5 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'3:Tree'0.t_Tree k v) (rcolor'3:Color'0.t_Color) (rkey'3:k) (rval'3:v) (rright'3:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'3}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 5) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_23 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'3 rcolor'3 rkey'3 rval'3 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s6)))
      | s6 = as_mut'0 {_23} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_22 <- _ret' ] s7)
      | s7 = bb3 ]
      
    | bb3 = s0 [ s0 = unwrap'0 {_22} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_21 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = Node'0.t_Node <k> <v> {_21.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id _21) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_20 <- _ret' ] 
                 [ &_21 <- { _21 with current = Node'0.C_Node rleft'0 _ret'.final rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = Borrow.borrow_final <Color'0.t_Color> {_20.current} {Borrow.get_id _20}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_19 <- _ret' ] 
             [ &_20 <- { _20 with current = _ret'.final ; } ] 
            s2)
      | s2 = swap'0 {_17} {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'1 _20}- s3
      | s3 = -{resolve'1 _18}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 = return' {_0} ]
       ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node k v) = self
    | & _13 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _14 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _16 : () = any_l ()
    | & _17 : borrowed (Color'0.t_Color) = any_l ()
    | & _18 : borrowed (Color'0.t_Color) = any_l ()
    | & _19 : borrowed (Color'0.t_Color) = any_l ()
    | & _20 : borrowed (Color'0.t_Color) = any_l ()
    | & _21 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _22 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _23 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree10] exists r1 : Node'0.t_Node k v, r2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[@expl:postcondition] [%#sred_black_tree9] exists l1 : Node'0.t_Node k v, l2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[@expl:postcondition] [%#sred_black_tree8] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key self.final}
      {[@expl:postcondition] [%#sred_black_tree7] same_mappings'0 self.current self.final}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__balance [#"../red_black_tree.rs" 541 4 541 25] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 522 15 522 43
  let%span sred_black_tree1 = "../red_black_tree.rs" 523 4 524 47
  let%span sred_black_tree2 = "../red_black_tree.rs" 525 4 526 48
  let%span sred_black_tree3 = "../red_black_tree.rs" 527 4 527 110
  let%span sred_black_tree4 = "../red_black_tree.rs" 541 20 541 24
  let%span sred_black_tree5 = "../red_black_tree.rs" 528 14 528 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 529 14 529 42
  let%span sred_black_tree7 = "../red_black_tree.rs" 530 14 530 50
  let%span sred_black_tree8 = "../red_black_tree.rs" 531 4 532 34
  let%span sred_black_tree9 = "../red_black_tree.rs" 533 4 534 39
  let%span sred_black_tree10 = "../red_black_tree.rs" 535 4 536 63
  let%span sred_black_tree11 = "../red_black_tree.rs" 537 4 538 61
  let%span sred_black_tree12 = "../red_black_tree.rs" 539 4 540 39
  let%span span13 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span14 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span28 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span29 = "../red_black_tree.rs" 294 12 297 13
  let%span span30 = "../red_black_tree.rs" 318 20 318 102
  let%span span31 = "../red_black_tree.rs" 304 12 310 13
  let%span span32 = "../red_black_tree.rs" 270 12 275 13
  let%span span33 = "../red_black_tree.rs" 323 8 323 112
  let%span span34 = "../red_black_tree.rs" 282 12 285 13
  let%span span35 = "../red_black_tree.rs" 263 16 263 48
  let%span span36 = "../red_black_tree.rs" 331 14 331 25
  let%span span37 = "../red_black_tree.rs" 334 12 342 13
  let%span span38 = "../red_black_tree.rs" 362 4 363 77
  let%span span39 = "../red_black_tree.rs" 366 12 369 13
  let%span span40 = "../red_black_tree.rs" 37 12 41 13
  let%span span41 = "../red_black_tree.rs" 142 4 143 86
  let%span span42 = "../red_black_tree.rs" 145 8 148 9
  let%span span43 = "../red_black_tree.rs" 153 8 155 9
  let%span span44 = "../red_black_tree.rs" 375 20 375 61
  let%span span45 = "../red_black_tree.rs" 349 12 355 13
  let%span span46 = "../red_black_tree.rs" 380 8 380 115
  let%span span47 = "../red_black_tree.rs" 222 12 223 104
  let%span span48 = "../red_black_tree.rs" 242 12 248 13
  let%span span49 = "../red_black_tree.rs" 229 8 231 9
  let%span span50 = "../red_black_tree.rs" 410 12 410 59
  let%span span51 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span52 = "../red_black_tree.rs" 503 15 503 43
  let%span span53 = "../red_black_tree.rs" 504 15 504 40
  let%span span54 = "../red_black_tree.rs" 505 15 505 41
  let%span span55 = "../red_black_tree.rs" 506 15 506 60
  let%span span56 = "../red_black_tree.rs" 517 24 517 28
  let%span span57 = "../red_black_tree.rs" 507 14 507 42
  let%span span58 = "../red_black_tree.rs" 508 14 508 50
  let%span span59 = "../red_black_tree.rs" 509 14 509 42
  let%span span60 = "../red_black_tree.rs" 510 14 510 40
  let%span span61 = "../red_black_tree.rs" 511 4 513 70
  let%span span62 = "../red_black_tree.rs" 514 4 516 90
  let%span span63 = "../red_black_tree.rs" 431 15 431 43
  let%span span64 = "../red_black_tree.rs" 432 15 432 42
  let%span span65 = "../red_black_tree.rs" 443 25 443 29
  let%span span66 = "../red_black_tree.rs" 433 14 433 42
  let%span span67 = "../red_black_tree.rs" 434 14 434 42
  let%span span68 = "../red_black_tree.rs" 435 14 435 50
  let%span span69 = "../red_black_tree.rs" 436 14 436 65
  let%span span70 = "../red_black_tree.rs" 437 14 437 42
  let%span span71 = "../red_black_tree.rs" 438 14 438 44
  let%span span72 = "../red_black_tree.rs" 439 4 442 36
  let%span span73 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span74 = "" 0 0 0 0
  let%span span75 = "" 0 0 0 0
  let%span span76 = "" 0 0 0 0
  let%span span77 = "../../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span span78 = "../../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span span79 = "" 0 0 0 0
  let%span span80 = "../red_black_tree.rs" 481 15 481 43
  let%span span81 = "../red_black_tree.rs" 482 15 482 43
  let%span span82 = "../red_black_tree.rs" 493 24 493 28
  let%span span83 = "../red_black_tree.rs" 483 14 483 42
  let%span span84 = "../red_black_tree.rs" 484 14 484 42
  let%span span85 = "../red_black_tree.rs" 485 14 485 50
  let%span span86 = "../red_black_tree.rs" 486 14 486 65
  let%span span87 = "../red_black_tree.rs" 487 14 487 41
  let%span span88 = "../red_black_tree.rs" 488 14 488 44
  let%span span89 = "../red_black_tree.rs" 489 4 492 36
  let%span span90 = "../red_black_tree.rs" 419 15 419 19
  let%span span91 = "../red_black_tree.rs" 418 14 418 45
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'0 (_1 : Node'0.t_Node k v)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'6 (self : Node'0.t_Node k v) =
    [%#span13] inv'0 self
  
  predicate inv'10 (_1 : Node'0.t_Node k v)
  
  axiom inv'10 [@rewrite] : forall x : Node'0.t_Node k v [inv'10 x] . inv'10 x = invariant'6 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'9 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'9 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'9 x] . inv'9 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  predicate invariant'5 (self : v)
  
  predicate inv'8 (_1 : v)
  
  axiom inv'8 : forall x : v [inv'8 x] . inv'8 x  -> invariant'5 x
  
  predicate invariant'4 (self : k)
  
  predicate inv'7 (_1 : k)
  
  axiom inv'7 : forall x : k [inv'7 x] . inv'7 x  -> invariant'4 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'6 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'6 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'6 x] . inv'6 x
  = match x with
    | Tree'0.C_Tree node -> inv'9 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : Node'0.t_Node k v) =
    [%#span14] inv'10 self
  
  predicate inv'5 (_1 : Node'0.t_Node k v)
  
  axiom inv'5 [@rewrite] : forall x : Node'0.t_Node k v [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate inv'4 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'4 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  predicate invariant'2 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span14] inv'9 self
  
  predicate inv'3 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'3 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'3 x] . inv'3 x = invariant'2 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span15] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span16] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span17] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span18] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span19] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span20] cmp_log'0 x y
  = o)  -> ([%#span21] cmp_log'0 y z = o)  -> ([%#span22] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span23] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span24] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span25] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span26] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span27] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'1 (self : Tree'0.t_Tree k v) =
    [%#span14] inv'6 self
  
  predicate inv'2 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'2 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node k v)) =
    [%#span28] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node k v [inv'0 x] . inv'0 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'6 left /\ inv'7 key /\ inv'8 val' /\ inv'6 right
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span29] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span30] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span32] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span33] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span34] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span35] CP'0.C_CPN c l r
  
  use prelude.prelude.Int
  
  function height'1 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span37] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree k v . [%#span36] height'1 self >= 0
  
  function height'0 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span39] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node k v . [%#span38] forall node : Node'0.t_Node k v . self = node
   -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span42] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span41] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span43] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v = has_mapping'0 o k v
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span44] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span45] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span46] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span47] (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span49] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span50] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span51] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'1 _1
  
  let rec flip_colors'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span56] inv'1 self}
    {[@expl:precondition] [%#span55] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span54] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#span53] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#span52] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span62] exists r1 : Node'0.t_Node k v, r2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[%#span61] exists l1 : Node'0.t_Node k v, l2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[%#span60] T_red_black_tree__Node.t_Node__key self.current = T_red_black_tree__Node.t_Node__key self.final}
      {[%#span59] same_mappings'0 self.current self.final}
      {[%#span58] height'0 self.current = height'0 self.final}
      {[%#span57] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span65] inv'1 self}
    {[@expl:precondition] [%#span64] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span63] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span72] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span71] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span70] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#span69] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#span68] height'0 self.current = height'0 self.final}
      {[%#span67] internal_invariant'0 self.final}
      {[%#span66] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span74] inv'4 self}
    {[@expl:precondition] [%#span73] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span75] inv'5 result}
      {[%#span73] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span76] inv'3 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span79] inv'4 result}
      {[%#span78] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node k v . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#span77] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec rotate_left'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span82] inv'1 self}
    {[@expl:precondition] [%#span81] color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span80] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span89] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l
      /\ (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.final)
      = (T_red_black_tree__Node.t_Node__left self.current, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      /\ T_red_black_tree__Node.t_Node__key l = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span88] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span87] color'0 (T_red_black_tree__Node.t_Node__left self.final) = Color'0.C_Red}
      {[%#span86] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final))}
      {[%#span85] height'0 self.current = height'0 self.final}
      {[%#span84] internal_invariant'0 self.final}
      {[%#span83] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span90] inv'2 self}
    any [ return' (result:bool)-> {[%#span91] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec balance (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[%#sred_black_tree4] inv'1 self}
    {[%#sred_black_tree3] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[%#sred_black_tree2] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[%#sred_black_tree1] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = bb1 ]
      
    | bb1 = any [ br0 -> {_15 = false} (! bb7) | br1 -> {_15} (! bb2) ] 
    | bb2 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1))
      | s1 = bb3 ]
      
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ] 
    | bb4 = bb8
    | bb5 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_20 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_left'0 {_20} (fun (_ret':()) ->  [ &_19 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = bb9
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                as_ref'0 {rnode'0} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_27 <- _ret' ] s1)))
      | s1 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':Node'0.t_Node k v) ->  [ &_26 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {_26}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1))
      | s1 = bb14 ]
      
    | bb14 = any [ br0 -> {_24 = false} (! bb17) | br1 -> {_24} (! bb15) ] 
    | bb15 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = bb20
    | bb17 = bb19
    | bb18 = bb19
    | bb19 = bb20
    | bb20 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s1))
      | s1 = bb21 ]
      
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ] 
    | bb22 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1))
      | s1 = bb23 ]
      
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ] 
    | bb24 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <Node'0.t_Node k v> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_36 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_36} (fun (_ret':()) ->  [ &_35 <- _ret' ] s2)
      | s2 = bb25 ]
      
    | bb25 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb29 ] 
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb28 ] 
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb28 ] 
    | bb28 = bb29
    | bb29 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node k v) = self
    | & _15 : bool = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : () = any_l ()
    | & _20 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : bool = any_l ()
    | & _26 : Node'0.t_Node k v = any_l ()
    | & _27 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _29 : () = any_l ()
    | & _30 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _31 : bool = any_l ()
    | & _33 : bool = any_l ()
    | & _35 : () = any_l ()
    | & _36 : borrowed (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree12] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[@expl:postcondition] [%#sred_black_tree11] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[@expl:postcondition] [%#sred_black_tree10] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[@expl:postcondition] [%#sred_black_tree9] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[@expl:postcondition] [%#sred_black_tree8] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[@expl:postcondition] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__move_red_left [#"../red_black_tree.rs" 573 4 573 44] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 555 15 555 41
  let%span sred_black_tree1 = "../red_black_tree.rs" 556 15 556 43
  let%span sred_black_tree2 = "../red_black_tree.rs" 557 15 557 86
  let%span sred_black_tree3 = "../red_black_tree.rs" 573 26 573 30
  let%span sred_black_tree4 = "../red_black_tree.rs" 558 14 558 44
  let%span sred_black_tree5 = "../red_black_tree.rs" 559 4 561 48
  let%span sred_black_tree6 = "../red_black_tree.rs" 562 4 562 97
  let%span sred_black_tree7 = "../red_black_tree.rs" 563 14 563 42
  let%span sred_black_tree8 = "../red_black_tree.rs" 564 4 564 105
  let%span sred_black_tree9 = "../red_black_tree.rs" 565 4 566 47
  let%span sred_black_tree10 = "../red_black_tree.rs" 567 4 568 108
  let%span sred_black_tree11 = "../red_black_tree.rs" 569 14 570 61
  let%span sred_black_tree12 = "../red_black_tree.rs" 571 4 572 45
  let%span sred_black_tree13 = "../red_black_tree.rs" 573 35 573 44
  let%span span14 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span30 = "../red_black_tree.rs" 294 12 297 13
  let%span span31 = "../red_black_tree.rs" 318 20 318 102
  let%span span32 = "../red_black_tree.rs" 304 12 310 13
  let%span span33 = "../red_black_tree.rs" 323 8 323 112
  let%span span34 = "../red_black_tree.rs" 37 12 41 13
  let%span span35 = "../red_black_tree.rs" 142 4 143 86
  let%span span36 = "../red_black_tree.rs" 145 8 148 9
  let%span span37 = "../red_black_tree.rs" 331 14 331 25
  let%span span38 = "../red_black_tree.rs" 334 12 342 13
  let%span span39 = "../red_black_tree.rs" 362 4 363 77
  let%span span40 = "../red_black_tree.rs" 366 12 369 13
  let%span span41 = "../red_black_tree.rs" 270 12 275 13
  let%span span42 = "../red_black_tree.rs" 282 12 285 13
  let%span span43 = "../red_black_tree.rs" 263 16 263 48
  let%span span44 = "../red_black_tree.rs" 375 20 375 61
  let%span span45 = "../red_black_tree.rs" 349 12 355 13
  let%span span46 = "../red_black_tree.rs" 380 8 380 115
  let%span span47 = "../red_black_tree.rs" 222 12 223 104
  let%span span48 = "../red_black_tree.rs" 242 12 248 13
  let%span span49 = "../red_black_tree.rs" 229 8 231 9
  let%span span50 = "../red_black_tree.rs" 410 12 410 59
  let%span span51 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span52 = "../red_black_tree.rs" 153 8 155 9
  let%span span53 = "../red_black_tree.rs" 481 15 481 43
  let%span span54 = "../red_black_tree.rs" 482 15 482 43
  let%span span55 = "../red_black_tree.rs" 493 24 493 28
  let%span span56 = "../red_black_tree.rs" 483 14 483 42
  let%span span57 = "../red_black_tree.rs" 484 14 484 42
  let%span span58 = "../red_black_tree.rs" 485 14 485 50
  let%span span59 = "../red_black_tree.rs" 486 14 486 65
  let%span span60 = "../red_black_tree.rs" 487 14 487 41
  let%span span61 = "../red_black_tree.rs" 488 14 488 44
  let%span span62 = "../red_black_tree.rs" 489 4 492 36
  let%span span63 = "../red_black_tree.rs" 431 15 431 43
  let%span span64 = "../red_black_tree.rs" 432 15 432 42
  let%span span65 = "../red_black_tree.rs" 443 25 443 29
  let%span span66 = "../red_black_tree.rs" 433 14 433 42
  let%span span67 = "../red_black_tree.rs" 434 14 434 42
  let%span span68 = "../red_black_tree.rs" 435 14 435 50
  let%span span69 = "../red_black_tree.rs" 436 14 436 65
  let%span span70 = "../red_black_tree.rs" 437 14 437 42
  let%span span71 = "../red_black_tree.rs" 438 14 438 44
  let%span span72 = "../red_black_tree.rs" 439 4 442 36
  let%span span73 = "../red_black_tree.rs" 419 15 419 19
  let%span span74 = "../red_black_tree.rs" 418 14 418 45
  let%span span75 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span76 = "" 0 0 0 0
  let%span span77 = "" 0 0 0 0
  let%span span78 = "" 0 0 0 0
  let%span span79 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span80 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span81 = "" 0 0 0 0
  let%span span82 = "../red_black_tree.rs" 503 15 503 43
  let%span span83 = "../red_black_tree.rs" 504 15 504 40
  let%span span84 = "../red_black_tree.rs" 505 15 505 41
  let%span span85 = "../red_black_tree.rs" 506 15 506 60
  let%span span86 = "../red_black_tree.rs" 517 24 517 28
  let%span span87 = "../red_black_tree.rs" 507 14 507 42
  let%span span88 = "../red_black_tree.rs" 508 14 508 50
  let%span span89 = "../red_black_tree.rs" 509 14 509 42
  let%span span90 = "../red_black_tree.rs" 510 14 510 40
  let%span span91 = "../red_black_tree.rs" 511 4 513 70
  let%span span92 = "../red_black_tree.rs" 514 4 516 90
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'0 (_1 : Node'0.t_Node k v)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'6 (self : Node'0.t_Node k v) =
    [%#span14] inv'0 self
  
  predicate inv'10 (_1 : Node'0.t_Node k v)
  
  axiom inv'10 [@rewrite] : forall x : Node'0.t_Node k v [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate invariant'5 (self : v)
  
  predicate inv'9 (_1 : v)
  
  axiom inv'9 : forall x : v [inv'9 x] . inv'9 x  -> invariant'5 x
  
  predicate invariant'4 (self : k)
  
  predicate inv'8 (_1 : k)
  
  axiom inv'8 : forall x : k [inv'8 x] . inv'8 x  -> invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'7 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'7 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'7 x] . inv'7 x
  = match x with
    | Tree'0.C_Tree node -> inv'1 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : Tree'0.t_Tree k v) =
    [%#span15] inv'7 self
  
  predicate inv'6 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'6 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'5 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'5 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate invariant'2 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span16] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'4 x] . inv'4 x
  = invariant'2 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span17] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span18] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span19] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span20] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span21] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span22] cmp_log'0 x y
  = o)  -> ([%#span23] cmp_log'0 y z = o)  -> ([%#span24] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span25] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span26] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span27] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span28] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span29] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span16] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'3 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node k v)) =
    [%#span16] inv'10 self.current /\ inv'10 self.final
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'0 x
  
  axiom inv'1 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node k v [inv'0 x] . inv'0 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'7 left /\ inv'8 key /\ inv'9 val' /\ inv'7 right
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span30] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span31] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span33] color_invariant_here'0 self
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span34] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span36] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span35] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  use prelude.prelude.Int
  
  function height'1 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span38] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree k v . [%#span37] height'1 self >= 0
  
  function height'0 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span40] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node k v . [%#span39] forall node : Node'0.t_Node k v . self = node
   -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span41] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'1 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span42] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'0 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span43] CP'0.C_CPN c l r
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span44] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span45] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span46] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span47] (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span49] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span50] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span51] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'3 _1
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span52] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec rotate_left'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span55] inv'3 self}
    {[@expl:precondition] [%#span54] color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span53] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span62] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l
      /\ (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.final)
      = (T_red_black_tree__Node.t_Node__left self.current, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      /\ T_red_black_tree__Node.t_Node__key l = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span61] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span60] color'0 (T_red_black_tree__Node.t_Node__left self.final) = Color'0.C_Red}
      {[%#span59] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final))}
      {[%#span58] height'0 self.current = height'0 self.final}
      {[%#span57] internal_invariant'0 self.final}
      {[%#span56] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span65] inv'3 self}
    {[@expl:precondition] [%#span64] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span63] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span72] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span71] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span70] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#span69] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#span68] height'0 self.current = height'0 self.final}
      {[%#span67] internal_invariant'0 self.final}
      {[%#span66] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span51] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'2 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span73] inv'6 self}
    any [ return' (result:bool)-> {[%#span74] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span76] inv'5 self}
    {[@expl:precondition] [%#span75] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span77] inv'2 result}
      {[%#span75] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span78] inv'4 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span81] inv'5 result}
      {[%#span80] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span79] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec flip_colors'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span86] inv'3 self}
    {[@expl:precondition] [%#span85] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span84] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#span83] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#span82] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span92] exists r1 : Node'0.t_Node k v, r2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[%#span91] exists l1 : Node'0.t_Node k v, l2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[%#span90] T_red_black_tree__Node.t_Node__key self.current = T_red_black_tree__Node.t_Node__key self.final}
      {[%#span89] same_mappings'0 self.current self.final}
      {[%#span88] height'0 self.current = height'0 self.final}
      {[%#span87] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_left (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[%#sred_black_tree3] inv'3 self}
    {[%#sred_black_tree2] match_n'0 (cpn'0 (Color'0.C_Red) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree1] internal_invariant'0 self.current}
    {[%#sred_black_tree0] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'1 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_22 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_22} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 = unwrap'0 {_21} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_20 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = Node'0.t_Node <k> <v> {_20.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]  ]
      
    | bb5 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'1 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_28 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_28} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_26 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {inv'0 _26.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_26.current} {Borrow.get_id _26}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_26 <- { _26 with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'2 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s3)
      | s3 = rotate_left'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s4)
      | s4 = bb9 ]
      
    | bb9 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_32 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_32} (fun (_ret':()) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'1 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_35 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_35} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = s0 [ s0 = unwrap'0 {_34} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_33 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {inv'0 _33.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_33.current} {Borrow.get_id _33}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_33 <- { _33 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _33} s2
      | s2 = -{resolve'0 _33}- s3
      | s3 = bb16 ]
      
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb14 ] 
    | bb13 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = bb14 ] 
    | bb14 = return' {_0} ]
    )
    [ & _0 : borrowed (Node'0.t_Node k v) = any_l ()
    | & self : borrowed (Node'0.t_Node k v) = self
    | & _15 : () = any_l ()
    | & _16 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _21 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _24 : () = any_l ()
    | & _25 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _26 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _27 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _28 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _29 : () = any_l ()
    | & _30 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _31 : () = any_l ()
    | & _32 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _33 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _34 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _35 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l () ]
    
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[@expl:postcondition] [%#sred_black_tree13] inv'3 result}
      {[@expl:postcondition] [%#sred_black_tree12] color_invariant'0 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__right result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree11] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[@expl:postcondition] [%#sred_black_tree10] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:postcondition] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
      /\ le_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))
       -> has_mapping'0 result.current k v}
      {[@expl:postcondition] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : v . has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:postcondition] [%#sred_black_tree7] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key result.current}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree4] internal_invariant'0 result.current}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__move_red_right [#"../red_black_tree.rs" 602 4 602 45] (* Node<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 584 15 584 40
  let%span sred_black_tree1 = "../red_black_tree.rs" 585 15 585 43
  let%span sred_black_tree2 = "../red_black_tree.rs" 586 15 586 86
  let%span sred_black_tree3 = "../red_black_tree.rs" 602 27 602 31
  let%span sred_black_tree4 = "../red_black_tree.rs" 587 14 587 44
  let%span sred_black_tree5 = "../red_black_tree.rs" 588 4 590 48
  let%span sred_black_tree6 = "../red_black_tree.rs" 591 4 591 97
  let%span sred_black_tree7 = "../red_black_tree.rs" 592 14 592 42
  let%span sred_black_tree8 = "../red_black_tree.rs" 593 4 593 105
  let%span sred_black_tree9 = "../red_black_tree.rs" 594 4 595 47
  let%span sred_black_tree10 = "../red_black_tree.rs" 596 4 597 108
  let%span sred_black_tree11 = "../red_black_tree.rs" 598 14 599 61
  let%span sred_black_tree12 = "../red_black_tree.rs" 600 4 601 45
  let%span sred_black_tree13 = "../red_black_tree.rs" 602 36 602 45
  let%span span14 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span30 = "../red_black_tree.rs" 294 12 297 13
  let%span span31 = "../red_black_tree.rs" 318 20 318 102
  let%span span32 = "../red_black_tree.rs" 304 12 310 13
  let%span span33 = "../red_black_tree.rs" 323 8 323 112
  let%span span34 = "../red_black_tree.rs" 37 12 41 13
  let%span span35 = "../red_black_tree.rs" 142 4 143 86
  let%span span36 = "../red_black_tree.rs" 145 8 148 9
  let%span span37 = "../red_black_tree.rs" 331 14 331 25
  let%span span38 = "../red_black_tree.rs" 334 12 342 13
  let%span span39 = "../red_black_tree.rs" 362 4 363 77
  let%span span40 = "../red_black_tree.rs" 366 12 369 13
  let%span span41 = "../red_black_tree.rs" 270 12 275 13
  let%span span42 = "../red_black_tree.rs" 282 12 285 13
  let%span span43 = "../red_black_tree.rs" 263 16 263 48
  let%span span44 = "../red_black_tree.rs" 375 20 375 61
  let%span span45 = "../red_black_tree.rs" 349 12 355 13
  let%span span46 = "../red_black_tree.rs" 380 8 380 115
  let%span span47 = "../red_black_tree.rs" 222 12 223 104
  let%span span48 = "../red_black_tree.rs" 242 12 248 13
  let%span span49 = "../red_black_tree.rs" 229 8 231 9
  let%span span50 = "../red_black_tree.rs" 410 12 410 59
  let%span span51 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span52 = "../red_black_tree.rs" 153 8 155 9
  let%span span53 = "../red_black_tree.rs" 431 15 431 43
  let%span span54 = "../red_black_tree.rs" 432 15 432 42
  let%span span55 = "../red_black_tree.rs" 443 25 443 29
  let%span span56 = "../red_black_tree.rs" 433 14 433 42
  let%span span57 = "../red_black_tree.rs" 434 14 434 42
  let%span span58 = "../red_black_tree.rs" 435 14 435 50
  let%span span59 = "../red_black_tree.rs" 436 14 436 65
  let%span span60 = "../red_black_tree.rs" 437 14 437 42
  let%span span61 = "../red_black_tree.rs" 438 14 438 44
  let%span span62 = "../red_black_tree.rs" 439 4 442 36
  let%span span63 = "../red_black_tree.rs" 419 15 419 19
  let%span span64 = "../red_black_tree.rs" 418 14 418 45
  let%span span65 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span66 = "" 0 0 0 0
  let%span span67 = "" 0 0 0 0
  let%span span68 = "" 0 0 0 0
  let%span span69 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span70 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span71 = "" 0 0 0 0
  let%span span72 = "../red_black_tree.rs" 503 15 503 43
  let%span span73 = "../red_black_tree.rs" 504 15 504 40
  let%span span74 = "../red_black_tree.rs" 505 15 505 41
  let%span span75 = "../red_black_tree.rs" 506 15 506 60
  let%span span76 = "../red_black_tree.rs" 517 24 517 28
  let%span span77 = "../red_black_tree.rs" 507 14 507 42
  let%span span78 = "../red_black_tree.rs" 508 14 508 50
  let%span span79 = "../red_black_tree.rs" 509 14 509 42
  let%span span80 = "../red_black_tree.rs" 510 14 510 40
  let%span span81 = "../red_black_tree.rs" 511 4 513 70
  let%span span82 = "../red_black_tree.rs" 514 4 516 90
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'0 (_1 : Node'0.t_Node k v)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'6 (self : Node'0.t_Node k v) =
    [%#span14] inv'0 self
  
  predicate inv'10 (_1 : Node'0.t_Node k v)
  
  axiom inv'10 [@rewrite] : forall x : Node'0.t_Node k v [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate invariant'5 (self : v)
  
  predicate inv'9 (_1 : v)
  
  axiom inv'9 : forall x : v [inv'9 x] . inv'9 x  -> invariant'5 x
  
  predicate invariant'4 (self : k)
  
  predicate inv'8 (_1 : k)
  
  axiom inv'8 : forall x : k [inv'8 x] . inv'8 x  -> invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'7 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'7 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'7 x] . inv'7 x
  = match x with
    | Tree'0.C_Tree node -> inv'1 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : Tree'0.t_Tree k v) =
    [%#span15] inv'7 self
  
  predicate inv'6 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'6 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'5 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'5 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate invariant'2 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span16] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'4 x] . inv'4 x
  = invariant'2 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span17] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span18] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span19] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span20] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span21] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span22] cmp_log'0 x y
  = o)  -> ([%#span23] cmp_log'0 y z = o)  -> ([%#span24] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span25] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span26] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span27] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span28] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span29] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span16] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'3 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node k v)) =
    [%#span16] inv'10 self.current /\ inv'10 self.final
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'0 x
  
  axiom inv'1 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node k v [inv'0 x] . inv'0 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'7 left /\ inv'8 key /\ inv'9 val' /\ inv'7 right
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span30] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span31] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span33] color_invariant_here'0 self
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span34] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span36] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span35] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  use prelude.prelude.Int
  
  function height'1 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span38] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree k v . [%#span37] height'1 self >= 0
  
  function height'0 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span40] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node k v . [%#span39] forall node : Node'0.t_Node k v . self = node
   -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span41] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'1 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span42] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'0 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span43] CP'0.C_CPN c l r
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span44] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span45] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span46] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span47] (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span49] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span50] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span51] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'3 _1
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span52] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span55] inv'3 self}
    {[@expl:precondition] [%#span54] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span53] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span62] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span61] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span60] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#span59] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#span58] height'0 self.current = height'0 self.final}
      {[%#span57] internal_invariant'0 self.final}
      {[%#span56] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span51] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'2 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span63] inv'6 self}
    any [ return' (result:bool)-> {[%#span64] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span66] inv'5 self}
    {[@expl:precondition] [%#span65] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span67] inv'2 result}
      {[%#span65] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span68] inv'4 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span71] inv'5 result}
      {[%#span70] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span69] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec flip_colors'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span76] inv'3 self}
    {[@expl:precondition] [%#span75] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span74] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#span73] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#span72] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span82] exists r1 : Node'0.t_Node k v, r2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[%#span81] exists l1 : Node'0.t_Node k v, l2 : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[%#span80] T_red_black_tree__Node.t_Node__key self.current = T_red_black_tree__Node.t_Node__key self.final}
      {[%#span79] same_mappings'0 self.current self.final}
      {[%#span78] height'0 self.current = height'0 self.final}
      {[%#span77] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_right (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[%#sred_black_tree3] inv'3 self}
    {[%#sred_black_tree2] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black)))) self.current}
    {[%#sred_black_tree1] internal_invariant'0 self.current}
    {[%#sred_black_tree0] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'1 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_22 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_22} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 = unwrap'0 {_21} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_20 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = Node'0.t_Node <k> <v> {_20.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]  ]
      
    | bb5 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_27 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_27} (fun (_ret':()) ->  [ &_26 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = Node'0.t_Node <k> <v> {self.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'1 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 5) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_30 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_30} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0 [ s0 = unwrap'0 {_29} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_28 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = {inv'0 _28.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_28 <- { _28 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _28} s2
      | s2 = -{resolve'0 _28}- s3
      | s3 = bb13 ]
      
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb11 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : borrowed (Node'0.t_Node k v) = any_l ()
    | & self : borrowed (Node'0.t_Node k v) = self
    | & _15 : () = any_l ()
    | & _16 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _21 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _24 : () = any_l ()
    | & _25 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _26 : () = any_l ()
    | & _27 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _28 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _29 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _30 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l () ]
    
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[@expl:postcondition] [%#sred_black_tree13] inv'3 result}
      {[@expl:postcondition] [%#sred_black_tree12] color_invariant'0 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__left result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree11] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[@expl:postcondition] [%#sred_black_tree10] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:postcondition] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
      /\ le_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) k
       -> has_mapping'0 result.current k v}
      {[@expl:postcondition] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : v . has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:postcondition] [%#sred_black_tree7] T_red_black_tree__Node.t_Node__key result.current
      = T_red_black_tree__Node.t_Node__key self.current}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree4] internal_invariant'0 result.current}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__insert_rec [#"../red_black_tree.rs" 625 4 625 44] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 617 15 617 43
  let%span sred_black_tree1 = "../red_black_tree.rs" 618 15 618 40
  let%span sred_black_tree2 = "../red_black_tree.rs" 625 23 625 27
  let%span sred_black_tree3 = "../red_black_tree.rs" 625 29 625 32
  let%span sred_black_tree4 = "../red_black_tree.rs" 625 37 625 40
  let%span sred_black_tree5 = "../red_black_tree.rs" 619 14 619 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 620 14 620 50
  let%span sred_black_tree7 = "../red_black_tree.rs" 621 14 622 39
  let%span sred_black_tree8 = "../red_black_tree.rs" 623 14 623 56
  let%span sred_black_tree9 = "../red_black_tree.rs" 624 4 624 127
  let%span span10 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span24 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span25 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span26 = "../red_black_tree.rs" 37 12 41 13
  let%span span27 = "../red_black_tree.rs" 294 12 297 13
  let%span span28 = "../red_black_tree.rs" 318 20 318 102
  let%span span29 = "../red_black_tree.rs" 304 12 310 13
  let%span span30 = "../red_black_tree.rs" 270 12 275 13
  let%span span31 = "../red_black_tree.rs" 263 16 263 48
  let%span span32 = "../red_black_tree.rs" 331 14 331 25
  let%span span33 = "../red_black_tree.rs" 334 12 342 13
  let%span span34 = "../red_black_tree.rs" 375 20 375 61
  let%span span35 = "../red_black_tree.rs" 349 12 355 13
  let%span span36 = "../red_black_tree.rs" 222 12 223 104
  let%span span37 = "../red_black_tree.rs" 242 12 248 13
  let%span span38 = "../red_black_tree.rs" 394 12 394 59
  let%span span39 = "../red_black_tree.rs" 323 8 323 112
  let%span span40 = "../red_black_tree.rs" 282 12 285 13
  let%span span41 = "../red_black_tree.rs" 362 4 363 77
  let%span span42 = "../red_black_tree.rs" 366 12 369 13
  let%span span43 = "../red_black_tree.rs" 142 4 143 86
  let%span span44 = "../red_black_tree.rs" 145 8 148 9
  let%span span45 = "../red_black_tree.rs" 153 8 155 9
  let%span span46 = "../red_black_tree.rs" 380 8 380 115
  let%span span47 = "../red_black_tree.rs" 229 8 231 9
  let%span span48 = "../red_black_tree.rs" 410 12 410 59
  let%span span49 = "../red_black_tree.rs" 522 15 522 43
  let%span span50 = "../red_black_tree.rs" 523 4 524 47
  let%span span51 = "../red_black_tree.rs" 525 4 526 48
  let%span span52 = "../red_black_tree.rs" 527 4 527 110
  let%span span53 = "../red_black_tree.rs" 541 20 541 24
  let%span span54 = "../red_black_tree.rs" 528 14 528 42
  let%span span55 = "../red_black_tree.rs" 529 14 529 42
  let%span span56 = "../red_black_tree.rs" 530 14 530 50
  let%span span57 = "../red_black_tree.rs" 531 4 532 34
  let%span span58 = "../red_black_tree.rs" 533 4 534 39
  let%span span59 = "../red_black_tree.rs" 535 4 536 63
  let%span span60 = "../red_black_tree.rs" 537 4 538 61
  let%span span61 = "../red_black_tree.rs" 539 4 540 39
  let%span span62 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span63 = "" 0 0 0 0
  let%span span64 = "" 0 0 0 0
  let%span span65 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span span66 = "../red_black_tree.rs" 201 8 203 9
  let%span span67 = "../../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span span68 = "../../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'8 (_1 : Node'0.t_Node k v)
  
  use prelude.prelude.Borrow
  
  predicate invariant'7 (self : borrowed (Node'0.t_Node k v)) =
    [%#span10] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'10 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'10 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'10 x] . inv'10 x = invariant'7 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span11] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span12] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span13] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span14] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span15] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span16] cmp_log'0 x y
  = o)  -> ([%#span17] cmp_log'0 y z = o)  -> ([%#span18] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span19] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span20] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span21] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'5 (_1 : k)
  
  predicate invariant'6 (self : k) =
    [%#span24] inv'5 self
  
  predicate inv'9 (_1 : k)
  
  axiom inv'9 [@rewrite] : forall x : k [inv'9 x] . inv'9 x = invariant'6 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'6 (_1 : v)
  
  predicate inv'4 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'8 [@rewrite] : forall x : Node'0.t_Node k v [inv'8 x] . inv'8 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'4 left /\ inv'5 key /\ inv'6 val' /\ inv'4 right
    end
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span10] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : v)
  
  axiom inv'6 : forall x : v [inv'6 x] . inv'6 x  -> invariant'4 x
  
  predicate invariant'3 (self : k)
  
  axiom inv'5 : forall x : k [inv'5 x] . inv'5 x  -> invariant'3 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'4 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'4 x] . inv'4 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span25] inv'8 self
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span10] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'2 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span10] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span26] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span27] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span28] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span29] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span30] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span31] CP'0.C_CPN c l r
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span33] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span32] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span34] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span35] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span36] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span37] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span38] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span39] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span40] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span42] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node k v . [%#span41] forall node : Node'0.t_Node k v . self = node
   -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span44] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span43] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span45] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span46] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span47] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span48] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span53] inv'10 self}
    {[@expl:precondition] [%#span52] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#span51] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span50] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#span49] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#span61] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span60] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span59] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span58] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span57] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#span56] height'1 self.current = height'1 self.final}
      {[%#span55] internal_invariant'1 self.final}
      {[%#span54] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'11 (self : borrowed (Node'0.t_Node k v)) =
    [%#span62] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'11 _1
  
  predicate resolve'4 (_1 : v)
  
  predicate resolve'3 (_1 : k)
  
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] [%#span64] inv'9 other}
    {[@expl:precondition] [%#span63] inv'9 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#span65] result = cmp_log'0 (deep_model'0 self) (deep_model'0 other)}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span62] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'8 _1
  
  predicate resolve'15 [#"../red_black_tree.rs" 200 4 200 28] (self : Node'0.t_Node k v) =
    [%#span66] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v  -> resolve'4 v
  
  predicate resolve'14 (_1 : Node'0.t_Node k v) =
    resolve'15 _1
  
  predicate resolve'13 (self : Node'0.t_Node k v) =
    [%#span67] resolve'14 self
  
  predicate resolve'12 (_1 : Node'0.t_Node k v) =
    resolve'13 _1
  
  predicate resolve'7 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span68] match self with
      | Option'0.C_Some x -> resolve'12 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option (Node'0.t_Node k v)) =
    resolve'7 _1
  
  predicate resolve'6 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span62] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'6 _1
  
  meta "compute_max_steps" 1000000
  
  let rec insert_rec (self:borrowed (Tree'0.t_Tree k v)) (key:k) (val':v) (return'  (ret:()))= {[%#sred_black_tree4] inv'6 val'}
    {[%#sred_black_tree3] inv'5 key}
    {[%#sred_black_tree2] inv'2 self}
    {[%#sred_black_tree1] color_invariant'0 self.current}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_11 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = any
        [ br0 -> {_11.current = Option'0.C_None } (! bb19)
        | br1 (a:Node'0.t_Node k v)-> {_11.current = Option'0.C_Some a} (! bb3) ]
         ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'1 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 =  [ &_35 <- Option'0.C_None ] s3
      | s3 =  [ &_34 <- Tree'0.C_Tree _35 ] s4
      | s4 = bb20 ]
      
    | bb20 = s0
      [ s0 =  [ &_36 <- Color'0.C_Red ] s1
      | s1 =  [ &_40 <- Option'0.C_None ] s2
      | s2 =  [ &_39 <- Tree'0.C_Tree _40 ] s3
      | s3 = bb21 ]
      
    | bb21 = s0 [ s0 =  [ &_33 <- Node'0.C_Node _34 _36 key val' _39 ] s1 | s1 = bb22 ] 
    | bb22 = bb23
    | bb23 = bb24
    | bb24 = bb25
    | bb25 = bb26
    | bb26 = s0 [ s0 =  [ &_31 <- Option'0.C_Some _33 ] s1 | s1 = bb27 ] 
    | bb27 = bb28
    | bb28 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = Tree'0.C_Tree x'0} -> inv'0 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = Tree'0.C_Tree x'1} -> resolve'1 x'1
          | _ -> true
          end}-
        s2
      | s2 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
             [ &self <- { self with current = Tree'0.C_Tree _31 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb30 ]
      
    | bb30 = bb32
    | bb3 = bb4
    | bb4 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node k v> {_11.current}
          (fun (r0'0:Node'0.t_Node k v) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _11) 1}
              (fun (_ret':borrowed (Node'0.t_Node k v)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_11 <- { _11 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_18 <- rkey'0 ] 
            s2)
      | s2 = cmp'0 {key} {_18} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = any
      [ br0 -> {_15 = Ordering'0.C_Less } (! bb7)
      | br1 -> {_15 = Ordering'0.C_Equal } (! bb8)
      | br2 -> {_15 = Ordering'0.C_Greater } (! bb9) ]
      
    | bb9 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_25 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = insert_rec {_25} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = bb17
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'5 key} s1 | s1 = -{resolve'3 key}- s2 | s2 = bb12 ] 
    | bb12 = bb13
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match node with
          | {current = Node'0.C_Node _ _ _ x'0 _} -> inv'6 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node with
          | {current = Node'0.C_Node _ _ _ x'1 _} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 val' rright'0 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'7 node} s4
      | s4 = -{resolve'5 node}- s5
      | s5 = {[@expl:type invariant] inv'1 _11} s6
      | s6 = -{resolve'0 _11}- s7
      | s7 = {[@expl:type invariant] inv'2 self} s8
      | s8 = -{resolve'2 self}- s9
      | s9 = bb15 ]
      
    | bb15 = bb32
    | bb32 = bb33
    | bb33 = bb34
    | bb7 = bb10
    | bb10 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'4 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_20 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = insert_rec {_20} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = bb17
    | bb17 = s0
      [ s0 = {inv'8 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_29 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_29} (fun (_ret':()) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb18 ]
      
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'7 node} s1
      | s1 = -{resolve'5 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 = bb31 ]
      
    | bb31 = bb34
    | bb34 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Tree'0.t_Tree k v) = self
    | & key : k = key
    | & val' : v = val'
    | & _11 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _14 : () = any_l ()
    | & _15 : Ordering'0.t_Ordering = any_l ()
    | & _18 : k = any_l ()
    | & _20 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _25 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _28 : () = any_l ()
    | & _29 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _31 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _33 : Node'0.t_Node k v = any_l ()
    | & _34 : Tree'0.t_Tree k v = any_l ()
    | & _35 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _36 : Color'0.t_Color = any_l ()
    | & _39 : Tree'0.t_Tree k v = any_l ()
    | & _40 : Option'0.t_Option (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : v . k
      = deep_model'0 key
      \/ has_mapping'0 self.current k v = has_mapping'0 self.final k v}
      {[@expl:postcondition] [%#sred_black_tree8] has_mapping'0 self.final (deep_model'0 key) val'}
      {[@expl:postcondition] [%#sred_black_tree7] match_t'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final
      /\ color'0 self.current = Color'0.C_Red
      \/ color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__delete_max_rec [#"../red_black_tree.rs" 659 4 659 42] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 648 15 648 43
  let%span sred_black_tree1 = "../red_black_tree.rs" 649 15 650 62
  let%span sred_black_tree2 = "../red_black_tree.rs" 659 27 659 31
  let%span sred_black_tree3 = "../red_black_tree.rs" 651 14 651 42
  let%span sred_black_tree4 = "../red_black_tree.rs" 652 14 652 50
  let%span sred_black_tree5 = "../red_black_tree.rs" 653 14 653 66
  let%span sred_black_tree6 = "../red_black_tree.rs" 654 4 654 104
  let%span sred_black_tree7 = "../red_black_tree.rs" 655 4 656 73
  let%span sred_black_tree8 = "../red_black_tree.rs" 657 14 657 39
  let%span sred_black_tree9 = "../red_black_tree.rs" 658 4 658 69
  let%span sred_black_tree10 = "../red_black_tree.rs" 659 36 659 42
  let%span span11 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span25 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span26 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span27 = "../red_black_tree.rs" 294 12 297 13
  let%span span28 = "../red_black_tree.rs" 318 20 318 102
  let%span span29 = "../red_black_tree.rs" 304 12 310 13
  let%span span30 = "../red_black_tree.rs" 37 12 41 13
  let%span span31 = "../red_black_tree.rs" 331 14 331 25
  let%span span32 = "../red_black_tree.rs" 334 12 342 13
  let%span span33 = "../red_black_tree.rs" 263 16 263 48
  let%span span34 = "../red_black_tree.rs" 270 12 275 13
  let%span span35 = "../red_black_tree.rs" 375 20 375 61
  let%span span36 = "../red_black_tree.rs" 349 12 355 13
  let%span span37 = "../red_black_tree.rs" 222 12 223 104
  let%span span38 = "../red_black_tree.rs" 242 12 248 13
  let%span span39 = "../red_black_tree.rs" 394 12 394 59
  let%span span40 = "../red_black_tree.rs" 185 8 187 9
  let%span span41 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span42 = "" 0 0 0 0
  let%span span43 = "" 0 0 0 0
  let%span span44 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span45 = "../../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span span46 = "" 0 0 0 0
  let%span span47 = "../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span span48 = "../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span span49 = "" 0 0 0 0
  let%span span50 = "../red_black_tree.rs" 323 8 323 112
  let%span span51 = "../red_black_tree.rs" 282 12 285 13
  let%span span52 = "../red_black_tree.rs" 362 4 363 77
  let%span span53 = "../red_black_tree.rs" 366 12 369 13
  let%span span54 = "../red_black_tree.rs" 142 4 143 86
  let%span span55 = "../red_black_tree.rs" 145 8 148 9
  let%span span56 = "../red_black_tree.rs" 153 8 155 9
  let%span span57 = "../red_black_tree.rs" 380 8 380 115
  let%span span58 = "../red_black_tree.rs" 229 8 231 9
  let%span span59 = "../red_black_tree.rs" 410 12 410 59
  let%span span60 = "../red_black_tree.rs" 522 15 522 43
  let%span span61 = "../red_black_tree.rs" 523 4 524 47
  let%span span62 = "../red_black_tree.rs" 525 4 526 48
  let%span span63 = "../red_black_tree.rs" 527 4 527 110
  let%span span64 = "../red_black_tree.rs" 541 20 541 24
  let%span span65 = "../red_black_tree.rs" 528 14 528 42
  let%span span66 = "../red_black_tree.rs" 529 14 529 42
  let%span span67 = "../red_black_tree.rs" 530 14 530 50
  let%span span68 = "../red_black_tree.rs" 531 4 532 34
  let%span span69 = "../red_black_tree.rs" 533 4 534 39
  let%span span70 = "../red_black_tree.rs" 535 4 536 63
  let%span span71 = "../red_black_tree.rs" 537 4 538 61
  let%span span72 = "../red_black_tree.rs" 539 4 540 39
  let%span span73 = "../red_black_tree.rs" 584 15 584 40
  let%span span74 = "../red_black_tree.rs" 585 15 585 43
  let%span span75 = "../red_black_tree.rs" 586 15 586 86
  let%span span76 = "../red_black_tree.rs" 602 27 602 31
  let%span span77 = "../red_black_tree.rs" 587 14 587 44
  let%span span78 = "../red_black_tree.rs" 588 4 590 48
  let%span span79 = "../red_black_tree.rs" 591 4 591 97
  let%span span80 = "../red_black_tree.rs" 592 14 592 42
  let%span span81 = "../red_black_tree.rs" 593 4 593 105
  let%span span82 = "../red_black_tree.rs" 594 4 595 47
  let%span span83 = "../red_black_tree.rs" 596 4 597 108
  let%span span84 = "../red_black_tree.rs" 598 14 599 61
  let%span span85 = "../red_black_tree.rs" 600 4 601 45
  let%span span86 = "../red_black_tree.rs" 602 36 602 45
  let%span span87 = "" 0 0 0 0
  let%span span88 = "../../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span span89 = "../../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span span90 = "" 0 0 0 0
  let%span span91 = "../red_black_tree.rs" 431 15 431 43
  let%span span92 = "../red_black_tree.rs" 432 15 432 42
  let%span span93 = "../red_black_tree.rs" 443 25 443 29
  let%span span94 = "../red_black_tree.rs" 433 14 433 42
  let%span span95 = "../red_black_tree.rs" 434 14 434 42
  let%span span96 = "../red_black_tree.rs" 435 14 435 50
  let%span span97 = "../red_black_tree.rs" 436 14 436 65
  let%span span98 = "../red_black_tree.rs" 437 14 437 42
  let%span span99 = "../red_black_tree.rs" 438 14 438 44
  let%span span100 = "../red_black_tree.rs" 439 4 442 36
  let%span span101 = "../red_black_tree.rs" 419 15 419 19
  let%span span102 = "../red_black_tree.rs" 418 14 418 45
  let%span span103 = "" 0 0 0 0
  let%span span104 = "../../../../creusot-contracts/src/std/boxed.rs" 43 26 43 43
  let%span span105 = "../../../../creusot-contracts/src/std/boxed.rs" 44 26 44 43
  let%span span106 = "" 0 0 0 0
  let%span span107 = "" 0 0 0 0
  let%span span108 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span109 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span110 = "" 0 0 0 0
  
  predicate invariant'9 (self : v)
  
  predicate inv'15 (_1 : v)
  
  axiom inv'15 : forall x : v [inv'15 x] . inv'15 x  -> invariant'9 x
  
  predicate invariant'8 (self : k)
  
  predicate inv'14 (_1 : k)
  
  axiom inv'14 : forall x : k [inv'14 x] . inv'14 x  -> invariant'8 x
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node k v)
  
  use prelude.prelude.Borrow
  
  predicate invariant'7 (self : Node'0.t_Node k v) =
    [%#span11] inv'1 self
  
  predicate inv'13 (_1 : Node'0.t_Node k v)
  
  axiom inv'13 [@rewrite] : forall x : Node'0.t_Node k v [inv'13 x] . inv'13 x = invariant'7 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'12 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'12 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'12 x] . inv'12 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'13 a_0
    end
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  predicate invariant'6 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span11] inv'0 self
  
  predicate inv'11 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'11 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'11 x] . inv'11 x = invariant'6 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree k v)
  
  predicate invariant'5 (self : Tree'0.t_Tree k v) =
    [%#span11] inv'5 self
  
  predicate inv'10 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'10 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'9 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'9 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'9 x] . inv'9 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'8 (_1 : (k, v))
  
  axiom inv'8 [@rewrite] : forall x : (k, v) [inv'8 x] . inv'8 x = (let (a, b) = x in inv'14 a /\ inv'15 b)
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span12] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span13] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span14] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span15] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span16] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span17] cmp_log'0 x y
  = o)  -> ([%#span18] cmp_log'0 y z = o)  -> ([%#span19] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span20] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span21] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span24] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'4 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'7 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'7 x] . inv'7 x
  = invariant'4 x
  
  predicate invariant'3 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span25] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'6 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'6 x] . inv'6 x = invariant'3 x
  
  axiom inv'5 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span25] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'4 x] . inv'4 x = invariant'2 x
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span25] inv'1 self.current /\ inv'1 self.final
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'0 (self : Node'0.t_Node k v) =
    [%#span26] inv'3 self
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node k v [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span27] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span28] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span29] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span30] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span31] height'0 self >= 0
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span33] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span34] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span35] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span36] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span37] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span38] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span39] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'10 (_1 : v)
  
  predicate resolve'9 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span40] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'10 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree k v) =
    resolve'9 _1
  
  let rec unwrap'2 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span42] inv'0 self}
    {[@expl:precondition] [%#span41] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span43] inv'1 result}
      {[%#span41] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span44] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'8 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span45] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span46] inv'7 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span49] inv'0 result}
      {[%#span48] is_default'0 dest.final}
      {[%#span47] result = dest.current}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'7 _1
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span50] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span51] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span53] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node k v . [%#span52] forall node : Node'0.t_Node k v . self = node
   -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span55] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span54] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span56] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span57] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span58] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span59] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span64] inv'4 self}
    {[@expl:precondition] [%#span63] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#span62] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span61] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#span60] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#span72] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span71] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span70] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span69] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span68] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#span67] height'1 self.current = height'1 self.final}
      {[%#span66] internal_invariant'1 self.final}
      {[%#span65] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Node'0.t_Node k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'6 _1
  
  let rec move_red_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span76] inv'4 self}
    {[@expl:precondition] [%#span75] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black)))) self.current}
    {[@expl:precondition] [%#span74] internal_invariant'1 self.current}
    {[@expl:precondition] [%#span73] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span86] inv'4 result}
      {[%#span85] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__left result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#span84] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#span83] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#span82] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.current k v
      /\ le_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) k
       -> has_mapping'1 result.current k v}
      {[%#span81] forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#span80] T_red_black_tree__Node.t_Node__key result.current = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span79] height'1 result.current = height'1 result.final  -> height'1 self.current = height'1 self.final}
      {[%#span78] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#span77] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'1 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span42] inv'12 self}
    {[@expl:precondition] [%#span41] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span43] inv'13 result}
      {[%#span41] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span87] inv'11 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span90] inv'12 result}
      {[%#span89] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node k v . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#span88] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span93] inv'4 self}
    {[@expl:precondition] [%#span92] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span91] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#span100] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span99] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span98] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#span97] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#span96] height'1 self.current = height'1 self.final}
      {[%#span95] internal_invariant'1 self.final}
      {[%#span94] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span101] inv'10 self}
    any [ return' (result:bool)-> {[%#span102] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'5 _1
  
  let rec as_mut'1 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span103] inv'2 self}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span106] inv'4 result}
      {[%#span105] self.final = result.final}
      {[%#span104] self.current = result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span42] inv'9 self}
    {[@expl:precondition] [%#span41] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span43] inv'2 result}
      {[%#span41] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span107] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span110] inv'9 result}
      {[%#span109] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span108] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max_rec (self:borrowed (Tree'0.t_Tree k v)) (return'  (ret:(k, v)))= {[%#sred_black_tree2] inv'6 self}
    {[%#sred_black_tree1] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_15 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = as_mut'0 {_15} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'1 _13.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_13.current} {Borrow.get_id _13}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'1 {_12} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s3))
      | s3 = bb4 ]
      
    | bb4 = any [ br0 -> {_17 = false} (! bb7) | br1 -> {_17} (! bb5) ] 
    | bb5 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {node.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_19 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = bb8
    | bb7 = bb8
    | bb8 = Node'0.t_Node <k> <v> {node.current}
        (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
          Tree'0.t_Tree <k> <v> {rright'0}
            (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
              any
              [ br0 -> {rnode'0 = Option'0.C_None } (! bb9)
              | br1 (a:Node'0.t_Node k v)-> {rnode'0 = Option'0.C_Some a} (! bb15) ]
              ))
    | bb15 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb25
    | bb18 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                as_ref'0 {rnode'0} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_35 <- _ret' ] s1)))
      | s1 = bb19 ]
      
    | bb19 = s0 [ s0 = unwrap'1 {_35} (fun (_ret':Node'0.t_Node k v) ->  [ &_34 <- _ret' ] s1) | s1 = bb20 ] 
    | bb20 = s0
      [ s0 = Node'0.t_Node <k> <v> {_34}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s1))
      | s1 = bb21 ]
      
    | bb21 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb22) ] 
    | bb22 = bb25
    | bb25 = bb26
    | bb23 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_39 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_right'0 {_39} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb24 ]
      
    | bb24 = s0
      [ s0 = {inv'3 _38.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_38.current} {Borrow.get_id _38}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_37 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_38 <- { _38 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _37 ] s4
      | s4 = {[@expl:type invariant] inv'4 _38} s5
      | s5 = -{resolve'1 _38}- s6
      | s6 = bb26 ]
      
    | bb26 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'5 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_41 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_max_rec {_41} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s2)
      | s2 = bb27 ]
      
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_43 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_43} (fun (_ret':()) ->  [ &_42 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb29 ]
      
    | bb29 = bb31
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'4 node} s1 | s1 = -{resolve'1 node}- s2 | s2 = bb10 ] 
    | bb10 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_final
              <Option'0.t_Option (Node'0.t_Node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_26 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _26.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node k v)> {_26.current} {Borrow.get_id _26}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_26 <- { _26 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_25} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_24 <- _ret' ] s3)
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'3 _26}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = unwrap'2 {_24} (fun (_ret':Node'0.t_Node k v) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb12 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node _ _ _ _ x'0 -> inv'5 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | Node'0.C_Node _ _ _ _ x'1 -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node x'2 _ _ _ _ -> inv'5 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | Node'0.C_Node x'3 _ _ _ _ -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 = Node'0.t_Node <k> <v> {node1}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Node'0.t_Node <k> <v> {node1}
              (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
                 [ &_0 <- (rkey'0, rval'1) ] 
                s5))
      | s5 = bb13 ]
      
    | bb13 = bb14
    | bb14 = bb30
    | bb30 = bb31
    | bb31 = return' {_0} ]
    )
    [ & _0 : (k, v) = any_l ()
    | & self : borrowed (Tree'0.t_Tree k v) = self
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _12 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _13 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _14 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _16 : () = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : borrowed (Node'0.t_Node k v) = any_l ()
    | & node1 : Node'0.t_Node k v = any_l ()
    | & _24 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _25 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _26 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : bool = any_l ()
    | & _34 : Node'0.t_Node k v = any_l ()
    | & _35 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _37 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _38 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _39 : borrowed (Node'0.t_Node k v) = any_l ()
    | & r : (k, v) = any_l ()
    | & _41 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _42 : () = any_l ()
    | & _43 : borrowed (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:(k, v))-> {[@expl:postcondition] [%#sred_black_tree10] inv'8 result}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 self.current = Color'0.C_Black
       -> color'0 self.final = Color'0.C_Black}
      {[@expl:postcondition] [%#sred_black_tree8] color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[@expl:postcondition] [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
       -> le_log'0 k (deep_model'0 (let (a, _) = result in a))}
      {[@expl:postcondition] [%#sred_black_tree5] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:postcondition] [%#sred_black_tree4] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree3] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__delete_min_rec [#"../red_black_tree.rs" 687 4 687 42] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 676 15 676 43
  let%span sred_black_tree1 = "../red_black_tree.rs" 677 15 678 62
  let%span sred_black_tree2 = "../red_black_tree.rs" 687 27 687 31
  let%span sred_black_tree3 = "../red_black_tree.rs" 679 14 679 42
  let%span sred_black_tree4 = "../red_black_tree.rs" 680 14 680 50
  let%span sred_black_tree5 = "../red_black_tree.rs" 681 14 681 66
  let%span sred_black_tree6 = "../red_black_tree.rs" 682 4 682 104
  let%span sred_black_tree7 = "../red_black_tree.rs" 683 4 684 73
  let%span sred_black_tree8 = "../red_black_tree.rs" 685 14 685 39
  let%span sred_black_tree9 = "../red_black_tree.rs" 686 4 686 69
  let%span sred_black_tree10 = "../red_black_tree.rs" 687 36 687 42
  let%span span11 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span25 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span26 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span27 = "../red_black_tree.rs" 294 12 297 13
  let%span span28 = "../red_black_tree.rs" 318 20 318 102
  let%span span29 = "../red_black_tree.rs" 304 12 310 13
  let%span span30 = "../red_black_tree.rs" 37 12 41 13
  let%span span31 = "../red_black_tree.rs" 331 14 331 25
  let%span span32 = "../red_black_tree.rs" 334 12 342 13
  let%span span33 = "../red_black_tree.rs" 263 16 263 48
  let%span span34 = "../red_black_tree.rs" 270 12 275 13
  let%span span35 = "../red_black_tree.rs" 375 20 375 61
  let%span span36 = "../red_black_tree.rs" 349 12 355 13
  let%span span37 = "../red_black_tree.rs" 222 12 223 104
  let%span span38 = "../red_black_tree.rs" 242 12 248 13
  let%span span39 = "../red_black_tree.rs" 394 12 394 59
  let%span span40 = "../red_black_tree.rs" 185 8 187 9
  let%span span41 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span42 = "" 0 0 0 0
  let%span span43 = "" 0 0 0 0
  let%span span44 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span45 = "../../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span span46 = "" 0 0 0 0
  let%span span47 = "../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span span48 = "../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span span49 = "" 0 0 0 0
  let%span span50 = "../red_black_tree.rs" 323 8 323 112
  let%span span51 = "../red_black_tree.rs" 282 12 285 13
  let%span span52 = "../red_black_tree.rs" 362 4 363 77
  let%span span53 = "../red_black_tree.rs" 366 12 369 13
  let%span span54 = "../red_black_tree.rs" 142 4 143 86
  let%span span55 = "../red_black_tree.rs" 145 8 148 9
  let%span span56 = "../red_black_tree.rs" 153 8 155 9
  let%span span57 = "../red_black_tree.rs" 380 8 380 115
  let%span span58 = "../red_black_tree.rs" 229 8 231 9
  let%span span59 = "../red_black_tree.rs" 410 12 410 59
  let%span span60 = "../red_black_tree.rs" 522 15 522 43
  let%span span61 = "../red_black_tree.rs" 523 4 524 47
  let%span span62 = "../red_black_tree.rs" 525 4 526 48
  let%span span63 = "../red_black_tree.rs" 527 4 527 110
  let%span span64 = "../red_black_tree.rs" 541 20 541 24
  let%span span65 = "../red_black_tree.rs" 528 14 528 42
  let%span span66 = "../red_black_tree.rs" 529 14 529 42
  let%span span67 = "../red_black_tree.rs" 530 14 530 50
  let%span span68 = "../red_black_tree.rs" 531 4 532 34
  let%span span69 = "../red_black_tree.rs" 533 4 534 39
  let%span span70 = "../red_black_tree.rs" 535 4 536 63
  let%span span71 = "../red_black_tree.rs" 537 4 538 61
  let%span span72 = "../red_black_tree.rs" 539 4 540 39
  let%span span73 = "../red_black_tree.rs" 555 15 555 41
  let%span span74 = "../red_black_tree.rs" 556 15 556 43
  let%span span75 = "../red_black_tree.rs" 557 15 557 86
  let%span span76 = "../red_black_tree.rs" 573 26 573 30
  let%span span77 = "../red_black_tree.rs" 558 14 558 44
  let%span span78 = "../red_black_tree.rs" 559 4 561 48
  let%span span79 = "../red_black_tree.rs" 562 4 562 97
  let%span span80 = "../red_black_tree.rs" 563 14 563 42
  let%span span81 = "../red_black_tree.rs" 564 4 564 105
  let%span span82 = "../red_black_tree.rs" 565 4 566 47
  let%span span83 = "../red_black_tree.rs" 567 4 568 108
  let%span span84 = "../red_black_tree.rs" 569 14 570 61
  let%span span85 = "../red_black_tree.rs" 571 4 572 45
  let%span span86 = "../red_black_tree.rs" 573 35 573 44
  let%span span87 = "" 0 0 0 0
  let%span span88 = "../../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span span89 = "../../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span span90 = "" 0 0 0 0
  let%span span91 = "../red_black_tree.rs" 419 15 419 19
  let%span span92 = "../red_black_tree.rs" 418 14 418 45
  let%span span93 = "" 0 0 0 0
  let%span span94 = "../../../../creusot-contracts/src/std/boxed.rs" 43 26 43 43
  let%span span95 = "../../../../creusot-contracts/src/std/boxed.rs" 44 26 44 43
  let%span span96 = "" 0 0 0 0
  let%span span97 = "" 0 0 0 0
  let%span span98 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span99 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span100 = "" 0 0 0 0
  
  predicate invariant'9 (self : v)
  
  predicate inv'15 (_1 : v)
  
  axiom inv'15 : forall x : v [inv'15 x] . inv'15 x  -> invariant'9 x
  
  predicate invariant'8 (self : k)
  
  predicate inv'14 (_1 : k)
  
  axiom inv'14 : forall x : k [inv'14 x] . inv'14 x  -> invariant'8 x
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node k v)
  
  use prelude.prelude.Borrow
  
  predicate invariant'7 (self : Node'0.t_Node k v) =
    [%#span11] inv'1 self
  
  predicate inv'13 (_1 : Node'0.t_Node k v)
  
  axiom inv'13 [@rewrite] : forall x : Node'0.t_Node k v [inv'13 x] . inv'13 x = invariant'7 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'12 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'12 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'12 x] . inv'12 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'13 a_0
    end
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  predicate invariant'6 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span11] inv'0 self
  
  predicate inv'11 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'11 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'11 x] . inv'11 x = invariant'6 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree k v)
  
  predicate invariant'5 (self : Tree'0.t_Tree k v) =
    [%#span11] inv'5 self
  
  predicate inv'10 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'10 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'9 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'9 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'9 x] . inv'9 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'8 (_1 : (k, v))
  
  axiom inv'8 [@rewrite] : forall x : (k, v) [inv'8 x] . inv'8 x = (let (a, b) = x in inv'14 a /\ inv'15 b)
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span12] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span13] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span14] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span15] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span16] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span17] cmp_log'0 x y
  = o)  -> ([%#span18] cmp_log'0 y z = o)  -> ([%#span19] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span20] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span21] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span24] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'4 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'7 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'7 x] . inv'7 x
  = invariant'4 x
  
  predicate invariant'3 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span25] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'6 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'6 x] . inv'6 x = invariant'3 x
  
  axiom inv'5 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span25] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'4 x] . inv'4 x = invariant'2 x
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span25] inv'1 self.current /\ inv'1 self.final
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'0 (self : Node'0.t_Node k v) =
    [%#span26] inv'3 self
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node k v [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span27] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span28] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span29] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span30] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span31] height'0 self >= 0
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span33] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span34] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span35] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span36] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span37] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span38] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span39] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'10 (_1 : v)
  
  predicate resolve'9 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span40] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'10 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree k v) =
    resolve'9 _1
  
  let rec unwrap'2 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span42] inv'0 self}
    {[@expl:precondition] [%#span41] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span43] inv'1 result}
      {[%#span41] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span44] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'8 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span45] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span46] inv'7 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span49] inv'0 result}
      {[%#span48] is_default'0 dest.final}
      {[%#span47] result = dest.current}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'7 _1
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span50] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span51] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span53] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node k v . [%#span52] forall node : Node'0.t_Node k v . self = node
   -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span55] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span54] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span56] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span57] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span58] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span59] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span64] inv'4 self}
    {[@expl:precondition] [%#span63] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#span62] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span61] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#span60] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#span72] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span71] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span70] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span69] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span68] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#span67] height'1 self.current = height'1 self.final}
      {[%#span66] internal_invariant'1 self.final}
      {[%#span65] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Node'0.t_Node k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'6 _1
  
  let rec move_red_left'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span76] inv'4 self}
    {[@expl:precondition] [%#span75] match_n'0 (cpn'0 (Color'0.C_Red) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#span74] internal_invariant'1 self.current}
    {[@expl:precondition] [%#span73] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span86] inv'4 result}
      {[%#span85] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__right result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#span84] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#span83] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#span82] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.current k v
      /\ le_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))
       -> has_mapping'1 result.current k v}
      {[%#span81] forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#span80] T_red_black_tree__Node.t_Node__key self.current = T_red_black_tree__Node.t_Node__key result.current}
      {[%#span79] height'1 result.current = height'1 result.final  -> height'1 self.current = height'1 self.final}
      {[%#span78] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#span77] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'1 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span42] inv'12 self}
    {[@expl:precondition] [%#span41] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span43] inv'13 result}
      {[%#span41] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span87] inv'11 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span90] inv'12 result}
      {[%#span89] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node k v . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#span88] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span91] inv'10 self}
    any [ return' (result:bool)-> {[%#span92] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'5 _1
  
  let rec as_mut'1 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span93] inv'2 self}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span96] inv'4 result}
      {[%#span95] self.final = result.final}
      {[%#span94] self.current = result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span42] inv'9 self}
    {[@expl:precondition] [%#span41] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span43] inv'2 result}
      {[%#span41] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span97] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span100] inv'9 result}
      {[%#span99] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span98] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min_rec (self:borrowed (Tree'0.t_Tree k v)) (return'  (ret:(k, v)))= {[%#sred_black_tree2] inv'6 self}
    {[%#sred_black_tree1] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_15 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = as_mut'0 {_15} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'1 _13.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_13.current} {Borrow.get_id _13}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'1 {_12} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                any
                [ br0 -> {rnode'0 = Option'0.C_None } (! bb4)
                | br1 (a:Node'0.t_Node k v)-> {rnode'0 = Option'0.C_Some a} (! bb10) ]
                )) ]
      
    | bb10 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1))
      | s1 = bb11 ]
      
    | bb11 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                as_ref'0 {rnode'0} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_31 <- _ret' ] s1)))
      | s1 = bb14 ]
      
    | bb14 = s0 [ s0 = unwrap'1 {_31} (fun (_ret':Node'0.t_Node k v) ->  [ &_30 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = Node'0.t_Node <k> <v> {_30}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_35 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_left'0 {_35} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = s0
      [ s0 = {inv'3 _34.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_33 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_34 <- { _34 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _33 ] s4
      | s4 = {[@expl:type invariant] inv'4 _34} s5
      | s5 = -{resolve'1 _34}- s6
      | s6 = bb21 ]
      
    | bb21 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'5 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_37 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = delete_min_rec {_37} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_39 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_39} (fun (_ret':()) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb23 ]
      
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb24 ]
      
    | bb24 = bb26
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'4 node} s1 | s1 = -{resolve'1 node}- s2 | s2 = bb5 ] 
    | bb5 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_final
              <Option'0.t_Option (Node'0.t_Node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_22 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _22.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node k v)> {_22.current} {Borrow.get_id _22}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
             [ &_21 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_22 <- { _22 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_21} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_20 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'7 _22} s1
      | s1 = -{resolve'3 _22}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = unwrap'2 {_20} (fun (_ret':Node'0.t_Node k v) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node _ _ _ _ x'0 -> inv'5 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | Node'0.C_Node _ _ _ _ x'1 -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node x'2 _ _ _ _ -> inv'5 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | Node'0.C_Node x'3 _ _ _ _ -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 = Node'0.t_Node <k> <v> {node1}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Node'0.t_Node <k> <v> {node1}
              (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
                 [ &_0 <- (rkey'0, rval'1) ] 
                s5))
      | s5 = bb8 ]
      
    | bb8 = bb9
    | bb9 = bb25
    | bb25 = bb26
    | bb26 = return' {_0} ]
    )
    [ & _0 : (k, v) = any_l ()
    | & self : borrowed (Tree'0.t_Tree k v) = self
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _12 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _13 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _14 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & node1 : Node'0.t_Node k v = any_l ()
    | & _20 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _21 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _26 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _30 : Node'0.t_Node k v = any_l ()
    | & _31 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _33 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _34 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _35 : borrowed (Node'0.t_Node k v) = any_l ()
    | & r : (k, v) = any_l ()
    | & _37 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _38 : () = any_l ()
    | & _39 : borrowed (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:(k, v))-> {[@expl:postcondition] [%#sred_black_tree10] inv'8 result}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 self.current = Color'0.C_Black
       -> color'0 self.final = Color'0.C_Black}
      {[@expl:postcondition] [%#sred_black_tree8] color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[@expl:postcondition] [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'0 (let (a, _) = result in a)) k}
      {[@expl:postcondition] [%#sred_black_tree5] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:postcondition] [%#sred_black_tree4] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree3] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__delete_rec [#"../red_black_tree.rs" 713 4 713 55] (* Tree<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 743 24 743 59
  let%span sred_black_tree1 = "../red_black_tree.rs" 701 15 701 43
  let%span sred_black_tree2 = "../red_black_tree.rs" 702 15 703 62
  let%span sred_black_tree3 = "../red_black_tree.rs" 713 23 713 27
  let%span sred_black_tree4 = "../red_black_tree.rs" 713 29 713 32
  let%span sred_black_tree5 = "../red_black_tree.rs" 704 14 704 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 705 14 705 50
  let%span sred_black_tree7 = "../red_black_tree.rs" 706 14 709 5
  let%span sred_black_tree8 = "../red_black_tree.rs" 710 4 710 129
  let%span sred_black_tree9 = "../red_black_tree.rs" 711 14 711 39
  let%span sred_black_tree10 = "../red_black_tree.rs" 712 4 712 69
  let%span sred_black_tree11 = "../red_black_tree.rs" 713 41 713 55
  let%span span12 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span26 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span27 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span28 = "../red_black_tree.rs" 294 12 297 13
  let%span span29 = "../red_black_tree.rs" 318 20 318 102
  let%span span30 = "../red_black_tree.rs" 304 12 310 13
  let%span span31 = "../red_black_tree.rs" 37 12 41 13
  let%span span32 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span33 = "../red_black_tree.rs" 331 14 331 25
  let%span span34 = "../red_black_tree.rs" 334 12 342 13
  let%span span35 = "../red_black_tree.rs" 263 16 263 48
  let%span span36 = "../red_black_tree.rs" 270 12 275 13
  let%span span37 = "../red_black_tree.rs" 375 20 375 61
  let%span span38 = "../red_black_tree.rs" 349 12 355 13
  let%span span39 = "../red_black_tree.rs" 222 12 223 104
  let%span span40 = "../red_black_tree.rs" 242 12 248 13
  let%span span41 = "../red_black_tree.rs" 394 12 394 59
  let%span span42 = "../red_black_tree.rs" 323 8 323 112
  let%span span43 = "../red_black_tree.rs" 282 12 285 13
  let%span span44 = "../red_black_tree.rs" 362 4 363 77
  let%span span45 = "../red_black_tree.rs" 366 12 369 13
  let%span span46 = "../red_black_tree.rs" 142 4 143 86
  let%span span47 = "../red_black_tree.rs" 145 8 148 9
  let%span span48 = "../red_black_tree.rs" 153 8 155 9
  let%span span49 = "../red_black_tree.rs" 380 8 380 115
  let%span span50 = "../red_black_tree.rs" 229 8 231 9
  let%span span51 = "../red_black_tree.rs" 410 12 410 59
  let%span span52 = "../red_black_tree.rs" 522 15 522 43
  let%span span53 = "../red_black_tree.rs" 523 4 524 47
  let%span span54 = "../red_black_tree.rs" 525 4 526 48
  let%span span55 = "../red_black_tree.rs" 527 4 527 110
  let%span span56 = "../red_black_tree.rs" 541 20 541 24
  let%span span57 = "../red_black_tree.rs" 528 14 528 42
  let%span span58 = "../red_black_tree.rs" 529 14 529 42
  let%span span59 = "../red_black_tree.rs" 530 14 530 50
  let%span span60 = "../red_black_tree.rs" 531 4 532 34
  let%span span61 = "../red_black_tree.rs" 533 4 534 39
  let%span span62 = "../red_black_tree.rs" 535 4 536 63
  let%span span63 = "../red_black_tree.rs" 537 4 538 61
  let%span span64 = "../red_black_tree.rs" 539 4 540 39
  let%span span65 = "../red_black_tree.rs" 555 15 555 41
  let%span span66 = "../red_black_tree.rs" 556 15 556 43
  let%span span67 = "../red_black_tree.rs" 557 15 557 86
  let%span span68 = "../red_black_tree.rs" 573 26 573 30
  let%span span69 = "../red_black_tree.rs" 558 14 558 44
  let%span span70 = "../red_black_tree.rs" 559 4 561 48
  let%span span71 = "../red_black_tree.rs" 562 4 562 97
  let%span span72 = "../red_black_tree.rs" 563 14 563 42
  let%span span73 = "../red_black_tree.rs" 564 4 564 105
  let%span span74 = "../red_black_tree.rs" 565 4 566 47
  let%span span75 = "../red_black_tree.rs" 567 4 568 108
  let%span span76 = "../red_black_tree.rs" 569 14 570 61
  let%span span77 = "../red_black_tree.rs" 571 4 572 45
  let%span span78 = "../red_black_tree.rs" 573 35 573 44
  let%span span79 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span80 = "" 0 0 0 0
  let%span span81 = "" 0 0 0 0
  let%span span82 = "../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span span83 = "../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span span84 = "../red_black_tree.rs" 58 12 65 13
  let%span span85 = "../red_black_tree.rs" 177 20 177 54
  let%span span86 = "../red_black_tree.rs" 70 4 71 93
  let%span span87 = "../red_black_tree.rs" 78 12 86 13
  let%span span88 = "../red_black_tree.rs" 91 15 91 35
  let%span span89 = "../red_black_tree.rs" 92 4 92 94
  let%span span90 = "../red_black_tree.rs" 98 12 107 13
  let%span span91 = "../red_black_tree.rs" 112 15 112 35
  let%span span92 = "../red_black_tree.rs" 113 4 113 80
  let%span span93 = "../red_black_tree.rs" 119 12 119 61
  let%span span94 = "../red_black_tree.rs" 125 15 125 35
  let%span span95 = "../red_black_tree.rs" 126 15 126 38
  let%span span96 = "../red_black_tree.rs" 127 15 127 38
  let%span span97 = "../red_black_tree.rs" 128 14 128 22
  let%span span98 = "../red_black_tree.rs" 134 12 134 37
  let%span span99 = "../red_black_tree.rs" 676 15 676 43
  let%span span100 = "../red_black_tree.rs" 677 15 678 62
  let%span span101 = "../red_black_tree.rs" 687 27 687 31
  let%span span102 = "../red_black_tree.rs" 679 14 679 42
  let%span span103 = "../red_black_tree.rs" 680 14 680 50
  let%span span104 = "../red_black_tree.rs" 681 14 681 66
  let%span span105 = "../red_black_tree.rs" 682 4 682 104
  let%span span106 = "../red_black_tree.rs" 683 4 684 73
  let%span span107 = "../red_black_tree.rs" 685 14 685 39
  let%span span108 = "../red_black_tree.rs" 686 4 686 69
  let%span span109 = "../red_black_tree.rs" 687 36 687 42
  let%span span110 = "../red_black_tree.rs" 584 15 584 40
  let%span span111 = "../red_black_tree.rs" 585 15 585 43
  let%span span112 = "../red_black_tree.rs" 586 15 586 86
  let%span span113 = "../red_black_tree.rs" 602 27 602 31
  let%span span114 = "../red_black_tree.rs" 587 14 587 44
  let%span span115 = "../red_black_tree.rs" 588 4 590 48
  let%span span116 = "../red_black_tree.rs" 591 4 591 97
  let%span span117 = "../red_black_tree.rs" 592 14 592 42
  let%span span118 = "../red_black_tree.rs" 593 4 593 105
  let%span span119 = "../red_black_tree.rs" 594 4 595 47
  let%span span120 = "../red_black_tree.rs" 596 4 597 108
  let%span span121 = "../red_black_tree.rs" 598 14 599 61
  let%span span122 = "../red_black_tree.rs" 600 4 601 45
  let%span span123 = "../red_black_tree.rs" 602 36 602 45
  let%span span124 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span125 = "" 0 0 0 0
  let%span span126 = "" 0 0 0 0
  let%span span127 = "" 0 0 0 0
  let%span span128 = "../../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span span129 = "../../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span span130 = "" 0 0 0 0
  let%span span131 = "../red_black_tree.rs" 185 8 187 9
  let%span span132 = "../../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span span133 = "" 0 0 0 0
  let%span span134 = "../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span span135 = "../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span span136 = "" 0 0 0 0
  let%span span137 = "" 0 0 0 0
  let%span span138 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span139 = "../red_black_tree.rs" 431 15 431 43
  let%span span140 = "../red_black_tree.rs" 432 15 432 42
  let%span span141 = "../red_black_tree.rs" 443 25 443 29
  let%span span142 = "../red_black_tree.rs" 433 14 433 42
  let%span span143 = "../red_black_tree.rs" 434 14 434 42
  let%span span144 = "../red_black_tree.rs" 435 14 435 50
  let%span span145 = "../red_black_tree.rs" 436 14 436 65
  let%span span146 = "../red_black_tree.rs" 437 14 437 42
  let%span span147 = "../red_black_tree.rs" 438 14 438 44
  let%span span148 = "../red_black_tree.rs" 439 4 442 36
  let%span span149 = "../red_black_tree.rs" 419 15 419 19
  let%span span150 = "../red_black_tree.rs" 418 14 418 45
  let%span span151 = "" 0 0 0 0
  let%span span152 = "" 0 0 0 0
  let%span span153 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span span154 = "" 0 0 0 0
  let%span span155 = "../../../../creusot-contracts/src/std/boxed.rs" 43 26 43 43
  let%span span156 = "../../../../creusot-contracts/src/std/boxed.rs" 44 26 44 43
  let%span span157 = "" 0 0 0 0
  let%span span158 = "" 0 0 0 0
  let%span span159 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span160 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span161 = "" 0 0 0 0
  
  predicate inv'10 (_1 : v)
  
  predicate inv'8 (_1 : k)
  
  predicate inv'19 (_1 : (k, v))
  
  axiom inv'19 [@rewrite] : forall x : (k, v) [inv'19 x] . inv'19 x = (let (a, b) = x in inv'8 a /\ inv'10 b)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node k v)
  
  use prelude.prelude.Borrow
  
  predicate invariant'12 (self : Node'0.t_Node k v) =
    [%#span12] inv'1 self
  
  predicate inv'18 (_1 : Node'0.t_Node k v)
  
  axiom inv'18 [@rewrite] : forall x : Node'0.t_Node k v [inv'18 x] . inv'18 x = invariant'12 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'17 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'17 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'17 x] . inv'17 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'18 a_0
    end
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  predicate invariant'11 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span12] inv'0 self
  
  predicate inv'16 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'16 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'16 x] . inv'16 x = invariant'11 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'4 (_1 : Tree'0.t_Tree k v)
  
  predicate invariant'10 (self : Tree'0.t_Tree k v) =
    [%#span12] inv'4 self
  
  predicate inv'15 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'15 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'15 x] . inv'15 x = invariant'10 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span13] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span14] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span15] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span18] cmp_log'0 x y
  = o)  -> ([%#span19] cmp_log'0 y z = o)  -> ([%#span20] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span21] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span24] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span25] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'14 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'14 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'14 x] . inv'14 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'13 (_1 : Option'0.t_Option (k, v))
  
  axiom inv'13 [@rewrite] : forall x : Option'0.t_Option (k, v) [inv'13 x] . inv'13 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'19 a_0
    end
  
  predicate invariant'9 (self : k) =
    [%#span12] inv'8 self
  
  predicate inv'12 (_1 : k)
  
  axiom inv'12 [@rewrite] : forall x : k [inv'12 x] . inv'12 x = invariant'9 x
  
  predicate invariant'8 (self : borrowed v) =
    [%#span26] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'11 (_1 : borrowed v)
  
  axiom inv'11 [@rewrite] : forall x : borrowed v [inv'11 x] . inv'11 x = invariant'8 x
  
  predicate invariant'7 (self : v)
  
  axiom inv'10 : forall x : v [inv'10 x] . inv'10 x  -> invariant'7 x
  
  predicate invariant'6 (self : borrowed k) =
    [%#span26] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_1 : borrowed k)
  
  axiom inv'9 [@rewrite] : forall x : borrowed k [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'5 (self : k)
  
  axiom inv'8 : forall x : k [inv'8 x] . inv'8 x  -> invariant'5 x
  
  predicate invariant'4 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span26] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span26] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'6 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'6 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'6 x] . inv'6 x
  = invariant'3 x
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span26] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'5 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'5 x] . inv'5 x = invariant'2 x
  
  axiom inv'4 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'4 x] . inv'4 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'4 left /\ inv'8 key /\ inv'10 val' /\ inv'4 right
    end
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node k v)) =
    [%#span26] inv'1 self.current /\ inv'1 self.final
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'0 (self : Node'0.t_Node k v) =
    [%#span27] inv'3 self
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node k v [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span28] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span29] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span30] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  function deep_model'1 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  function deep_model'0 (self : k) : t_DeepModelTy'0 =
    [%#span32] deep_model'1 self
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span34] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span33] height'0 self >= 0
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span35] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span36] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span37] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span38] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span39] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span41] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate color_invariant'1 [#"../red_black_tree.rs" 322 4 322 36] (self : Node'0.t_Node k v) =
    [%#span42] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"../red_black_tree.rs" 280 4 280 52] (self : CP'0.t_CP) (node : Node'0.t_Node k v) =
    [%#span43] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"../red_black_tree.rs" 364 4 364 26] (self : Node'0.t_Node k v) : int =
    [%#span45] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node k v . [%#span44] forall node : Node'0.t_Node k v . self = node
   -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span47] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'1 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span46] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 152 4 152 43] (self : Node'0.t_Node k v) (o : Node'0.t_Node k v) =
    [%#span48] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"../red_black_tree.rs" 379 4 379 37] (self : Node'0.t_Node k v) =
    [%#span49] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"../red_black_tree.rs" 228 4 228 34] (self : Node'0.t_Node k v) =
    [%#span50] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"../red_black_tree.rs" 408 4 408 39] (self : Node'0.t_Node k v) =
    [%#span51] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span56] inv'5 self}
    {[@expl:precondition] [%#span55] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#span54] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#span53] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#span52] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#span64] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span63] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span62] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#span61] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#span60] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#span59] height'1 self.current = height'1 self.final}
      {[%#span58] internal_invariant'1 self.final}
      {[%#span57] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec move_red_left'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span68] inv'5 self}
    {[@expl:precondition] [%#span67] match_n'0 (cpn'0 (Color'0.C_Red) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#span66] internal_invariant'1 self.current}
    {[@expl:precondition] [%#span65] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span78] inv'5 result}
      {[%#span77] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__right result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#span76] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#span75] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#span74] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.current k v
      /\ le_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self.current))
       -> has_mapping'1 result.current k v}
      {[%#span73] forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#span72] T_red_black_tree__Node.t_Node__key self.current = T_red_black_tree__Node.t_Node__key result.current}
      {[%#span71] height'1 result.current = height'1 result.final  -> height'1 self.current = height'1 self.final}
      {[%#span70] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#span69] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  predicate resolve'13 (self : borrowed v) =
    [%#span79] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed v) =
    resolve'13 _1
  
  let rec swap'1 (x:borrowed v) (y:borrowed v) (return'  (ret:()))= {[@expl:precondition] [%#span81] inv'11 y}
    {[@expl:precondition] [%#span80] inv'11 x}
    any
    [ return' (result:())-> {[%#span83] y.final = x.current} {[%#span82] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'12 (self : borrowed k) =
    [%#span79] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed k) =
    resolve'12 _1
  
  let rec swap'0 (x:borrowed k) (y:borrowed k) (return'  (ret:()))= {[@expl:precondition] [%#span81] inv'9 y}
    {[@expl:precondition] [%#span80] inv'9 x}
    any
    [ return' (result:())-> {[%#span83] y.final = x.current} {[%#span82] x.final = y.current} (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span84] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'0 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span85] model_acc'0 self (Const.const (Option'0.C_None))
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span87] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span86] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span90] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span88] bst_invariant'0 self)
   -> ([%#span89] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span93] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span91] bst_invariant'0 self)
   -> ([%#span92] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'0 self) k = Option'0.C_Some v))
  
  function has_mapping_inj'0 [#"../red_black_tree.rs" 129 4 131 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v1 : v) (v2 : v) : ()
    
   =
    [%#span98] let _ = has_mapping_model'0 self k in match Map.get (shallow_model'0 self) k with
      | Option'0.C_None -> ()
      | Option'0.C_Some _v -> ()
      end
  
  axiom has_mapping_inj'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0, v1 : v, v2 : v . ([%#span94] bst_invariant'0 self)
   -> ([%#span95] has_mapping'0 self k v1)  -> ([%#span96] has_mapping'0 self k v2)  -> ([%#span97] v1 = v2)
  
  let rec delete_min_rec'0 (self:borrowed (Tree'0.t_Tree k v)) (return'  (ret:(k, v)))= {[@expl:precondition] [%#span101] inv'7 self}
    {[@expl:precondition] [%#span100] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#span99] internal_invariant'0 self.current}
    any
    [ return' (result:(k, v))-> {[%#span109] inv'19 result}
      {[%#span108] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#span107] color_invariant'0 self.final}
      {[%#span106] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'1 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#span105] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'1 (let (a, _) = result in a)) k}
      {[%#span104] has_mapping'0 self.current (deep_model'1 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#span103] height'0 self.current = height'0 self.final}
      {[%#span102] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  let rec move_red_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span113] inv'5 self}
    {[@expl:precondition] [%#span112] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black)))) self.current}
    {[@expl:precondition] [%#span111] internal_invariant'1 self.current}
    {[@expl:precondition] [%#span110] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span123] inv'5 result}
      {[%#span122] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__left result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#span121] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#span120] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#span119] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self.current k v
      /\ le_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self.current)) k
       -> has_mapping'1 result.current k v}
      {[%#span118] forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#span117] T_red_black_tree__Node.t_Node__key result.current = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span116] height'1 result.current = height'1 result.final  -> height'1 self.current = height'1 self.final}
      {[%#span115] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#span114] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'2 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span125] inv'17 self}
    {[@expl:precondition] [%#span124] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span126] inv'18 result}
      {[%#span124] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span127] inv'16 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span130] inv'17 result}
      {[%#span129] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node k v . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#span128] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  predicate resolve'14 (_1 : v)
  
  predicate resolve'11 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span131] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'14 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree k v) =
    resolve'11 _1
  
  let rec unwrap'1 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:Node'0.t_Node k v))= {[@expl:precondition] [%#span125] inv'0 self}
    {[@expl:precondition] [%#span124] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node k v)-> {[%#span126] inv'1 result}
      {[%#span124] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'10 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span79] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'10 _1
  
  predicate resolve'9 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span79] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'9 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span132] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (Node'0.t_Node k v)))= {[@expl:precondition] [%#span133] inv'6 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node k v))-> {[%#span136] inv'0 result}
      {[%#span135] is_default'0 dest.final}
      {[%#span134] result = dest.current}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Node'0.t_Node k v)) =
    [%#span79] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'8 _1
  
  let rec is_none'0 (self:Option'0.t_Option (Node'0.t_Node k v)) (return'  (ret:bool))= {[@expl:precondition] [%#span137] inv'16 self}
    any [ return' (result:bool)-> {[%#span138] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:()))= {[@expl:precondition] [%#span141] inv'5 self}
    {[@expl:precondition] [%#span140] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[@expl:precondition] [%#span139] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#span148] exists l : Node'0.t_Node k v, r : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#span147] T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color self.current}
      {[%#span146] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#span145] lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'1 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#span144] height'1 self.current = height'1 self.final}
      {[%#span143] internal_invariant'1 self.final}
      {[%#span142] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span149] inv'15 self}
    any [ return' (result:bool)-> {[%#span150] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] [%#span152] inv'12 other}
    {[@expl:precondition] [%#span151] inv'12 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#span153] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Node'0.t_Node k v)) =
    [%#span79] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'7 _1
  
  let rec as_mut'1 (self:borrowed (Node'0.t_Node k v)) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span154] inv'2 self}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span157] inv'5 result}
      {[%#span156] self.final = result.final}
      {[%#span155] self.current = result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span125] inv'14 self}
    {[@expl:precondition] [%#span124] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span126] inv'2 result}
      {[%#span124] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span158] inv'6 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span161] inv'14 result}
      {[%#span160] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span159] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec delete_rec (self:borrowed (Tree'0.t_Tree k v)) (key:k) (return'  (ret:Option'0.t_Option (k, v)))= {[%#sred_black_tree4] inv'12 key}
    {[%#sred_black_tree3] inv'7 self}
    {[%#sred_black_tree2] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree1] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_16 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = as_mut'0 {_16} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_15} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_14 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'1 _14.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_14.current} {Borrow.get_id _14}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_13 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_14 <- { _14 with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'1 {_13} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_21 <- rkey'0 ] 
            s3)
      | s3 = cmp'0 {key} {_21} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_18 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = any
      [ br0 -> {_18 = Ordering'0.C_Less } (! bb6)
      | br1 -> {_18 = Ordering'0.C_Equal } (! bb5)
      | br2 -> {_18 = Ordering'0.C_Greater } (! bb5) ]
      
    | bb5 = s0
      [ s0 =  [ &ord <- _18 ] s1
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s2))
      | s2 = bb26 ]
      
    | bb26 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ] 
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_mut <Node'0.t_Node k v> {node.current}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_45 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_45} (fun (_ret':()) ->  [ &_44 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_47 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_rec {_47} {key} (fun (_ret':Option'0.t_Option (k, v)) ->  [ &_46 <- _ret' ] s2)
      | s2 = bb29 ]
      
    | bb29 = bb30
    | bb30 = s0 [ s0 =  [ &r <- _46 ] s1 | s1 = bb32 ] 
    | bb32 = bb68
    | bb33 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                is_none'0 {rnode'0} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s1)))
      | s1 = bb34 ]
      
    | bb34 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ] 
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = any
        [ br0 -> {ord = Ordering'0.C_Less } (! bb38)
        | br1 -> {ord = Ordering'0.C_Equal } (! bb38)
        | br2 -> {ord = Ordering'0.C_Greater } (! bb36) ]
         ]
      
    | bb38 = s0
      [ s0 = Tree'0.t_Tree <k> <v> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
            {inv'0 rnode'0}
            Borrow.borrow_final
              <Option'0.t_Option (Node'0.t_Node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                 [ &_59 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _59.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node k v)> {_59.current} {Borrow.get_id _59}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
             [ &_58 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_59 <- { _59 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_58} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_57 <- _ret' ] s3)
      | s3 = bb39 ]
      
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'6 _59} s1
      | s1 = -{resolve'2 _59}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 = unwrap'1 {_57} (fun (_ret':Node'0.t_Node k v) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb40 ]
      
    | bb40 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node _ _ _ _ x'0 -> inv'4 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | Node'0.C_Node _ _ _ _ x'1 -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node x'2 _ _ _ _ -> inv'4 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | Node'0.C_Node x'3 _ _ _ _ -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 = Node'0.t_Node <k> <v> {node1}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Node'0.t_Node <k> <v> {node1}
              (fun (rleft'1:Tree'0.t_Tree k v) (rcolor'1:Color'0.t_Color) (rkey'1:k) (rval'1:v) (rright'1:Tree'0.t_Tree k v) ->
                 [ &_60 <- (rkey'0, rval'1) ] 
                s5))
      | s5 = bb41 ]
      
    | bb41 = bb42
    | bb42 = s0 [ s0 =  [ &_0 <- Option'0.C_Some _60 ] s1 | s1 = bb43 ] 
    | bb43 = bb72
    | bb72 = bb73
    | bb36 = s0 [ s0 = {[@expl:type invariant] inv'7 self} s1 | s1 = -{resolve'3 self}- s2 | s2 = bb37 ] 
    | bb37 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb73 ] 
    | bb73 = bb74
    | bb44 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                as_ref'0 {rnode'0} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_67 <- _ret' ] s1)))
      | s1 = bb45 ]
      
    | bb45 = s0 [ s0 = unwrap'2 {_67} (fun (_ret':Node'0.t_Node k v) ->  [ &_66 <- _ret' ] s1) | s1 = bb46 ] 
    | bb46 = s0
      [ s0 = Node'0.t_Node <k> <v> {_66}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_64 <- _ret' ] s1))
      | s1 = bb47 ]
      
    | bb47 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb48) ] 
    | bb48 = bb51
    | bb49 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_71 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_right'0 {_71} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_70 <- _ret' ] s2)
      | s2 = bb50 ]
      
    | bb50 = s0
      [ s0 = {inv'3 _70.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_70.current} {Borrow.get_id _70}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_69 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_70 <- { _70 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'5 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _69 ] s4
      | s4 = {[@expl:type invariant] inv'5 _70} s5
      | s5 = -{resolve'1 _70}- s6
      | s6 = bb51 ]
      
    | bb51 = any
      [ br0 -> {ord = Ordering'0.C_Less } (! bb63)
      | br1 -> {ord = Ordering'0.C_Equal } (! bb52)
      | br2 -> {ord = Ordering'0.C_Greater } (! bb63) ]
      
    | bb63 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_90 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_rec {_90} {key} (fun (_ret':Option'0.t_Option (k, v)) ->  [ &_89 <- _ret' ] s2)
      | s2 = bb64 ]
      
    | bb64 = bb65
    | bb65 = s0 [ s0 =  [ &r <- _89 ] s1 | s1 = bb67 ] 
    | bb67 = bb68
    | bb52 = bb53
    | bb53 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_74 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_min_rec'0 {_74} (fun (_ret':(k, v)) ->  [ &kv <- _ret' ] s2)
      | s2 = bb54 ]
      
    | bb54 = s0 [ s0 =  [ &_75 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb55 ] 
    | bb55 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'8 rkey'0}
            Borrow.borrow_mut <k> {rkey'0}
              (fun (_ret':borrowed k) ->
                 [ &_79 <- _ret' ] 
                -{inv'8 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 _ret'.final rval'0 rright'0 ; } ] 
                s1))
      | s1 = {inv'8 _79.current}
        Borrow.borrow_final <k> {_79.current} {Borrow.get_id _79}
          (fun (_ret':borrowed k) ->
             [ &_78 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &_79 <- { _79 with current = _ret'.final ; } ] 
            s2)
      | s2 = {inv'8 (let (r'0, _) = kv in r'0)}
        Borrow.borrow_mut <k> {let (r'0, _) = kv in r'0}
          (fun (_ret':borrowed k) ->
             [ &_81 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &kv <- let (_, r'2) = kv in (_ret'.final, r'2) ] 
            s3)
      | s3 = {inv'8 _81.current}
        Borrow.borrow_final <k> {_81.current} {Borrow.get_id _81}
          (fun (_ret':borrowed k) ->
             [ &_80 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &_81 <- { _81 with current = _ret'.final ; } ] 
            s4)
      | s4 = swap'0 {_78} {_80} (fun (_ret':()) ->  [ &_77 <- _ret' ] s5)
      | s5 = bb56 ]
      
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'9 _81} s1
      | s1 = -{resolve'5 _81}- s2
      | s2 = {[@expl:type invariant] inv'9 _79} s3
      | s3 = -{resolve'5 _79}- s4
      | s4 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'10 rval'0}
            Borrow.borrow_mut <v> {rval'0}
              (fun (_ret':borrowed v) ->
                 [ &_84 <- _ret' ] 
                -{inv'10 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 _ret'.final rright'0 ; } ] 
                s5))
      | s5 = {inv'10 _84.current}
        Borrow.borrow_final <v> {_84.current} {Borrow.get_id _84}
          (fun (_ret':borrowed v) ->
             [ &_83 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &_84 <- { _84 with current = _ret'.final ; } ] 
            s6)
      | s6 = {inv'10 (let (_, r'0) = kv in r'0)}
        Borrow.borrow_mut <v> {let (_, r'0) = kv in r'0}
          (fun (_ret':borrowed v) ->
             [ &_86 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &kv <- let (r'1, _) = kv in (r'1, _ret'.final) ] 
            s7)
      | s7 = {inv'10 _86.current}
        Borrow.borrow_final <v> {_86.current} {Borrow.get_id _86}
          (fun (_ret':borrowed v) ->
             [ &_85 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &_86 <- { _86 with current = _ret'.final ; } ] 
            s8)
      | s8 = swap'1 {_83} {_85} (fun (_ret':()) ->  [ &_82 <- _ret' ] s9)
      | s9 = bb57 ]
      
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'11 _86} s1
      | s1 = -{resolve'6 _86}- s2
      | s2 = {[@expl:type invariant] inv'11 _84} s3
      | s3 = -{resolve'6 _84}- s4
      | s4 =  [ &_87 <- Option'0.C_Some kv ] s5
      | s5 = bb58 ]
      
    | bb58 = bb59
    | bb59 = s0 [ s0 =  [ &r <- _87 ] s1 | s1 = bb61 ] 
    | bb61 = bb62
    | bb62 = bb68
    | bb68 = bb69
    | bb6 = bb7
    | bb7 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                is_none'0 {rnode'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)))
      | s1 = bb8 ]
      
    | bb8 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ] 
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb74 ]
      
    | bb74 = bb75
    | bb75 = bb76
    | bb10 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1))
      | s1 = bb11 ]
      
    | bb11 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                as_ref'0 {rnode'0} (fun (_ret':Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_33 <- _ret' ] s1)))
      | s1 = bb14 ]
      
    | bb14 = s0 [ s0 = unwrap'2 {_33} (fun (_ret':Node'0.t_Node k v) ->  [ &_32 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = Node'0.t_Node <k> <v> {_32}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_37 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_left'0 {_37} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_36 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = s0
      [ s0 = {inv'3 _36.current}
        Borrow.borrow_final <Node'0.t_Node k v> {_36.current} {Borrow.get_id _36}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_35 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_36 <- { _36 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'5 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _35 ] s4
      | s4 = {[@expl:type invariant] inv'5 _36} s5
      | s5 = -{resolve'1 _36}- s6
      | s6 = bb21 ]
      
    | bb21 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'4 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_39 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = delete_rec {_39} {key} (fun (_ret':Option'0.t_Option (k, v)) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = bb23
    | bb23 = s0 [ s0 =  [ &r <- _38 ] s1 | s1 = bb25 ] 
    | bb25 = bb69
    | bb69 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node k v> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node k v)) ->
             [ &_93 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_93} (fun (_ret':()) ->  [ &_92 <- _ret' ] s2)
      | s2 = bb70 ]
      
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb71 ]
      
    | bb71 = bb76
    | bb76 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (k, v) = any_l ()
    | & self : borrowed (Tree'0.t_Tree k v) = self
    | & key : k = key
    | & r : Option'0.t_Option (k, v) = any_l ()
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _13 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _14 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _15 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _16 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _18 : Ordering'0.t_Ordering = any_l ()
    | & _21 : k = any_l ()
    | & _24 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : Node'0.t_Node k v = any_l ()
    | & _33 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _35 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _36 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _37 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _38 : Option'0.t_Option (k, v) = any_l ()
    | & _39 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & ord : Ordering'0.t_Ordering = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : () = any_l ()
    | & _45 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _46 : Option'0.t_Option (k, v) = any_l ()
    | & _47 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _50 : bool = any_l ()
    | & node1 : Node'0.t_Node k v = any_l ()
    | & _57 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _58 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _59 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _60 : (k, v) = any_l ()
    | & _64 : bool = any_l ()
    | & _66 : Node'0.t_Node k v = any_l ()
    | & _67 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & _69 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _70 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _71 : borrowed (Node'0.t_Node k v) = any_l ()
    | & kv : (k, v) = any_l ()
    | & _74 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _75 : Snapshot.snap_ty () = any_l ()
    | & _77 : () = any_l ()
    | & _78 : borrowed k = any_l ()
    | & _79 : borrowed k = any_l ()
    | & _80 : borrowed k = any_l ()
    | & _81 : borrowed k = any_l ()
    | & _82 : () = any_l ()
    | & _83 : borrowed v = any_l ()
    | & _84 : borrowed v = any_l ()
    | & _85 : borrowed v = any_l ()
    | & _86 : borrowed v = any_l ()
    | & _87 : Option'0.t_Option (k, v) = any_l ()
    | & _89 : Option'0.t_Option (k, v) = any_l ()
    | & _90 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _92 : () = any_l ()
    | & _93 : borrowed (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:Option'0.t_Option (k, v))-> {[@expl:postcondition] [%#sred_black_tree11] inv'13 result}
      {[@expl:postcondition] [%#sred_black_tree10] color'0 self.current = Color'0.C_Black
       -> color'0 self.final = Color'0.C_Black}
      {[@expl:postcondition] [%#sred_black_tree9] color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'0 key <> k /\ has_mapping'0 self.current k v)}
      {[@expl:postcondition] [%#sred_black_tree7] match result with
        | Option'0.C_None -> forall v : v . not has_mapping'0 self.current (deep_model'0 key) v
        | Option'0.C_Some (k, v) -> deep_model'0 key = deep_model'1 k /\ has_mapping'0 self.current (deep_model'1 k) v
        end}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module T_red_black_tree__Map [#"../red_black_tree.rs" 760 0 760 20]
  use T_red_black_tree__Tree as Tree'0
  
  type t_Map 'k 'v =
    | C_Map (Tree'0.t_Tree 'k 'v)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Map < 'k > < 'v > (input:t_Map 'k 'v) (ret  (field_0:Tree'0.t_Tree 'k 'v))= any
    [ good (field_0:Tree'0.t_Tree 'k 'v)-> {C_Map field_0 = input} (! ret {field_0}) ]
    
  
  function t_Map__0 (self : t_Map 'k 'v) : Tree'0.t_Tree 'k 'v =
    match self with
      | C_Map a -> a
      end
end
module M_red_black_tree__qyi10312951825188598006__resolve_coherence [#"../red_black_tree.rs" 800 4 800 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 797 15 797 39
  let%span sred_black_tree1 = "../red_black_tree.rs" 798 14 798 31
  let%span span2 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span3 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span4 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span5 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span6 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span7 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span8 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span9 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span10 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span15 = "../red_black_tree.rs" 37 12 41 13
  let%span span16 = "../red_black_tree.rs" 58 12 65 13
  let%span span17 = "../red_black_tree.rs" 70 4 71 93
  let%span span18 = "../red_black_tree.rs" 78 12 86 13
  let%span span19 = "../red_black_tree.rs" 222 12 223 104
  let%span span20 = "../red_black_tree.rs" 242 12 248 13
  let%span span21 = "../red_black_tree.rs" 91 15 91 35
  let%span span22 = "../red_black_tree.rs" 92 4 92 94
  let%span span23 = "../red_black_tree.rs" 98 12 107 13
  let%span span24 = "../red_black_tree.rs" 177 20 177 54
  let%span span25 = "../red_black_tree.rs" 112 15 112 35
  let%span span26 = "../red_black_tree.rs" 113 4 113 80
  let%span span27 = "../red_black_tree.rs" 119 12 119 61
  let%span span28 = "../../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span span29 = "../red_black_tree.rs" 768 8 768 29
  let%span span30 = "../red_black_tree.rs" 792 8 792 70
  let%span span31 = "../red_black_tree.rs" 185 8 187 9
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span2] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span3] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span4] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span5] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span6] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span7] cmp_log'0 x y
  = o)  -> ([%#span8] cmp_log'0 y z = o)  -> ([%#span9] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span11] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span12] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span13] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span14] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span17] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span19] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span23] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span21] bst_invariant'0 self)
   -> ([%#span22] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  use map.Const
  
  function shallow_model'1 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span24] model_acc'0 self (Const.const (Option'0.C_None))
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span27] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span25] bst_invariant'0 self)
   -> ([%#span26] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'1 self) k = Option'0.C_Some v))
  
  use T_red_black_tree__Map as Map'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'5 (_1 : v)
  
  predicate resolve'4 (self : Option'0.t_Option v) =
    [%#span28] match self with
      | Option'0.C_Some x -> resolve'5 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'2 (_1 : Option'0.t_Option v) =
    resolve'4 _1
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  function shallow_model'0 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span29] shallow_model'1 (T_red_black_tree__Map.t_Map__0 self)
  
  predicate resolve'0 [#"../red_black_tree.rs" 791 4 791 28] (self : Map'0.t_Map k v) =
    [%#span30] forall k : t_DeepModelTy'0 . resolve'2 (Map.get (shallow_model'0 self) k)
  
  predicate resolve'3 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span31] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'5 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree k v) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Map'0.t_Map k v) =
    match x with
      | Map'0.C_Map a -> resolve'1 a
      end
  
  constant self  : Map'0.t_Map k v
  
  function resolve_coherence [#"../red_black_tree.rs" 800 4 800 31] (self : Map'0.t_Map k v) : ()
  
  goal vc_resolve_coherence : ([%#sred_black_tree0] structural_resolve'0 self)
   -> (let _ = has_mapping_model'0 in [%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi1501420612169366910__new [#"../red_black_tree.rs" 810 4 810 24] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 809 14 809 43
  let%span sred_black_tree1 = "../red_black_tree.rs" 810 20 810 24
  let%span span2 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span3 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span4 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span5 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span6 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span7 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span8 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span9 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span10 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span16 = "../red_black_tree.rs" 294 12 297 13
  let%span span17 = "../red_black_tree.rs" 318 20 318 102
  let%span span18 = "../red_black_tree.rs" 304 12 310 13
  let%span span19 = "../red_black_tree.rs" 331 14 331 25
  let%span span20 = "../red_black_tree.rs" 334 12 342 13
  let%span span21 = "../red_black_tree.rs" 375 20 375 61
  let%span span22 = "../red_black_tree.rs" 349 12 355 13
  let%span span23 = "../red_black_tree.rs" 37 12 41 13
  let%span span24 = "../red_black_tree.rs" 222 12 223 104
  let%span span25 = "../red_black_tree.rs" 242 12 248 13
  let%span span26 = "../red_black_tree.rs" 394 12 394 59
  let%span span27 = "../red_black_tree.rs" 779 8 781 9
  let%span span28 = "../red_black_tree.rs" 58 12 65 13
  let%span span29 = "../red_black_tree.rs" 177 20 177 54
  let%span span30 = "../red_black_tree.rs" 768 8 768 29
  
  predicate invariant'3 (self : v)
  
  predicate inv'6 (_1 : v)
  
  axiom inv'6 : forall x : v [inv'6 x] . inv'6 x  -> invariant'3 x
  
  predicate invariant'2 (self : k)
  
  predicate inv'5 (_1 : k)
  
  axiom inv'5 : forall x : k [inv'5 x] . inv'5 x  -> invariant'2 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'1 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node k v)
  
  axiom inv'4 [@rewrite] : forall x : Node'0.t_Node k v [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'1 left /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'1 (self : Node'0.t_Node k v) =
    [%#span2] inv'4 self
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span3] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span4] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span5] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span6] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span7] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span8] cmp_log'0 x y
  = o)  -> ([%#span9] cmp_log'0 y z = o)  -> ([%#span10] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span11] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span12] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span13] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span14] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span15] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv'1 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'1 x] . inv'1 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span16] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span17] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span19] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span21] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span22] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span23] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span24] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span25] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span26] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'0 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span27] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'0 (_1 : Map'0.t_Map k v)
  
  axiom inv'0 [@rewrite] : forall x : Map'0.t_Map k v [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'1 a_0
    end)
  
  use map.Const
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span28] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function shallow_model'1 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span29] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'0 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span30] shallow_model'1 (T_red_black_tree__Map.t_Map__0 self)
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec new (_1:()) (return'  (ret:Map'0.t_Map k v))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- Option'0.C_None ] s1 | s1 =  [ &_2 <- Tree'0.C_Tree _3 ] s2 | s2 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- Map'0.C_Map _2 ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    )
    [ & _0 : Map'0.t_Map k v = any_l ()
    | & _2 : Tree'0.t_Tree k v = any_l ()
    | & _3 : Option'0.t_Option (Node'0.t_Node k v) = any_l () ]
    
    [ return' (result:Map'0.t_Map k v)-> {[@expl:postcondition] [%#sred_black_tree1] inv'0 result}
      {[@expl:postcondition] [%#sred_black_tree0] shallow_model'0 result = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__insert [#"../red_black_tree.rs" 815 4 815 44] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 818 8 818 53
  let%span sred_black_tree1 = "../red_black_tree.rs" 815 23 815 27
  let%span sred_black_tree2 = "../red_black_tree.rs" 815 29 815 32
  let%span sred_black_tree3 = "../red_black_tree.rs" 815 37 815 40
  let%span sred_black_tree4 = "../red_black_tree.rs" 814 14 814 64
  let%span span5 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span6 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span7 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span8 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span9 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span10 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span11 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span12 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span13 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span14 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span15 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span16 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span17 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span18 = "../red_black_tree.rs" 294 12 297 13
  let%span span19 = "../red_black_tree.rs" 318 20 318 102
  let%span span20 = "../red_black_tree.rs" 304 12 310 13
  let%span span21 = "../red_black_tree.rs" 331 14 331 25
  let%span span22 = "../red_black_tree.rs" 334 12 342 13
  let%span span23 = "../red_black_tree.rs" 375 20 375 61
  let%span span24 = "../red_black_tree.rs" 349 12 355 13
  let%span span25 = "../red_black_tree.rs" 37 12 41 13
  let%span span26 = "../red_black_tree.rs" 222 12 223 104
  let%span span27 = "../red_black_tree.rs" 242 12 248 13
  let%span span28 = "../red_black_tree.rs" 394 12 394 59
  let%span span29 = "../red_black_tree.rs" 779 8 781 9
  let%span span30 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span31 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span32 = "../red_black_tree.rs" 58 12 65 13
  let%span span33 = "../red_black_tree.rs" 177 20 177 54
  let%span span34 = "../red_black_tree.rs" 768 8 768 29
  let%span span35 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span36 = "../red_black_tree.rs" 70 4 71 93
  let%span span37 = "../red_black_tree.rs" 78 12 86 13
  let%span span38 = "../red_black_tree.rs" 91 15 91 35
  let%span span39 = "../red_black_tree.rs" 92 4 92 94
  let%span span40 = "../red_black_tree.rs" 98 12 107 13
  let%span span41 = "../red_black_tree.rs" 112 15 112 35
  let%span span42 = "../red_black_tree.rs" 113 4 113 80
  let%span span43 = "../red_black_tree.rs" 119 12 119 61
  let%span span44 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span45 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span46 = "" 0 0 0 0
  let%span span47 = "" 0 0 0 0
  let%span span48 = "" 0 0 0 0
  let%span span49 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span50 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span51 = "" 0 0 0 0
  let%span span52 = "../red_black_tree.rs" 270 12 275 13
  let%span span53 = "../red_black_tree.rs" 263 16 263 48
  let%span span54 = "../red_black_tree.rs" 617 15 617 43
  let%span span55 = "../red_black_tree.rs" 618 15 618 40
  let%span span56 = "../red_black_tree.rs" 625 23 625 27
  let%span span57 = "../red_black_tree.rs" 625 29 625 32
  let%span span58 = "../red_black_tree.rs" 625 37 625 40
  let%span span59 = "../red_black_tree.rs" 619 14 619 42
  let%span span60 = "../red_black_tree.rs" 620 14 620 50
  let%span span61 = "../red_black_tree.rs" 621 14 622 39
  let%span span62 = "../red_black_tree.rs" 623 14 623 56
  let%span span63 = "../red_black_tree.rs" 624 4 624 127
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : v)
  
  predicate inv'4 (_1 : k)
  
  predicate inv'0 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'11 (_1 : Node'0.t_Node k v)
  
  axiom inv'11 [@rewrite] : forall x : Node'0.t_Node k v [inv'11 x] . inv'11 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'0 left /\ inv'4 key /\ inv'5 val' /\ inv'0 right
    end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span5] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span6] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span7] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span8] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span9] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span10] cmp_log'0 x y
  = o)  -> ([%#span11] cmp_log'0 y z = o)  -> ([%#span12] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span13] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span14] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span15] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span16] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span17] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span18] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span19] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span22] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span21] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span23] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span24] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span25] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span26] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span27] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span28] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'7 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span29] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'10 (_1 : Map'0.t_Map k v)
  
  axiom inv'10 [@rewrite] : forall x : Map'0.t_Map k v [inv'10 x] . inv'10 x
  = (invariant'7 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'0 a_0
    end)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'6 (self : Node'0.t_Node k v) =
    [%#span30] inv'11 self
  
  predicate inv'9 (_1 : Node'0.t_Node k v)
  
  axiom inv'9 [@rewrite] : forall x : Node'0.t_Node k v [inv'9 x] . inv'9 x = invariant'6 x
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'8 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'8 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'8 x] . inv'8 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'1 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  predicate invariant'5 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span31] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'7 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'7 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'7 x] . inv'7 x
  = invariant'5 x
  
  predicate invariant'4 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span31] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'6 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'6 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : v)
  
  axiom inv'5 : forall x : v [inv'5 x] . inv'5 x  -> invariant'3 x
  
  predicate invariant'2 (self : k)
  
  axiom inv'4 : forall x : k [inv'4 x] . inv'4 x  -> invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map k v)) =
    [%#span31] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'3 (_1 : borrowed (Map'0.t_Map k v))
  
  axiom inv'3 [@rewrite] : forall x : borrowed (Map'0.t_Map k v) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node k v)) =
    [%#span31] inv'9 self.current /\ inv'9 self.final
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'2 x] . inv'2 x = invariant'0 x
  
  axiom inv'1 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'9 a_0
    end
  
  axiom inv'0 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'0 x] . inv'0 x
  = match x with
    | Tree'0.C_Tree node -> inv'1 node
    end
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'2 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span33] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'0 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span34] shallow_model'2 (T_red_black_tree__Map.t_Map__0 self)
  
  function shallow_model'1 (self : borrowed (Map'0.t_Map k v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v) =
    [%#span35] shallow_model'0 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span37] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span36] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span38] bst_invariant'0 self)
   -> ([%#span39] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span43] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span41] bst_invariant'0 self)
   -> ([%#span42] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'2 self) k = Option'0.C_Some v))
  
  predicate resolve'3 (self : borrowed (Map'0.t_Map k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map k v)) =
    resolve'3 _1
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span44] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'2 _1
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span46] inv'8 self}
    {[@expl:precondition] [%#span45] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span47] inv'2 result}
      {[%#span45] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span48] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span51] inv'8 result}
      {[%#span50] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span49] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span52] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span53] CP'0.C_CPN c l r
  
  let rec insert_rec'0 (self:borrowed (Tree'0.t_Tree k v)) (key:k) (val':v) (return'  (ret:()))= {[@expl:precondition] [%#span58] inv'5 val'}
    {[@expl:precondition] [%#span57] inv'4 key}
    {[@expl:precondition] [%#span56] inv'6 self}
    {[@expl:precondition] [%#span55] color_invariant'0 self.current}
    {[@expl:precondition] [%#span54] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#span63] forall k : t_DeepModelTy'0, v : v . k = deep_model'0 key
      \/ has_mapping'0 self.current k v = has_mapping'0 self.final k v}
      {[%#span62] has_mapping'0 self.final (deep_model'0 key) val'}
      {[%#span61] match_t'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final
      /\ color'0 self.current = Color'0.C_Red
      \/ color_invariant'0 self.final}
      {[%#span60] height'0 self.current = height'0 self.final}
      {[%#span59] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec insert (self:borrowed (Map'0.t_Map k v)) (key:k) (val':v) (return'  (ret:()))= {[%#sred_black_tree3] inv'5 val'}
    {[%#sred_black_tree2] inv'4 key}
    {[%#sred_black_tree1] inv'3 self}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            {inv'0 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_6 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 = insert_rec'0 {_6} {key} {val'} (fun (_ret':()) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 =  [ &_9 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'1 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_12 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_12} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_11 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0 [ s0 = unwrap'0 {_11} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_10 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = Node'0.t_Node <k> <v> {_10.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_10 <- { _10 with current = Node'0.C_Node rleft'0 _9 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 =  [ &_13 <- [%#sred_black_tree0] Snapshot.new () ] s6
      | s6 = bb5 ]
      
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Map'0.t_Map k v) = self
    | & key : k = key
    | & val' : v = val'
    | & _5 : () = any_l ()
    | & _6 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _9 : Color'0.t_Color = any_l ()
    | & _10 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _11 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _12 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _13 : Snapshot.snap_ty () = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree4] shallow_model'0 self.final
      = Map.set (shallow_model'1 self) (deep_model'0 key) (Option'0.C_Some val')}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__delete_max [#"../red_black_tree.rs" 827 4 827 50] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 828 23 828 41
  let%span sred_black_tree1 = "../red_black_tree.rs" 836 8 836 58
  let%span sred_black_tree2 = "../red_black_tree.rs" 841 8 841 53
  let%span sred_black_tree3 = "../red_black_tree.rs" 827 27 827 31
  let%span sred_black_tree4 = "../red_black_tree.rs" 821 14 826 5
  let%span sred_black_tree5 = "../red_black_tree.rs" 827 36 827 50
  let%span span6 = "../red_black_tree.rs" 294 12 297 13
  let%span span7 = "../red_black_tree.rs" 318 20 318 102
  let%span span8 = "../red_black_tree.rs" 304 12 310 13
  let%span span9 = "../red_black_tree.rs" 331 14 331 25
  let%span span10 = "../red_black_tree.rs" 334 12 342 13
  let%span span11 = "../red_black_tree.rs" 375 20 375 61
  let%span span12 = "../red_black_tree.rs" 349 12 355 13
  let%span span13 = "../red_black_tree.rs" 37 12 41 13
  let%span span14 = "../red_black_tree.rs" 222 12 223 104
  let%span span15 = "../red_black_tree.rs" 242 12 248 13
  let%span span16 = "../red_black_tree.rs" 394 12 394 59
  let%span span17 = "../red_black_tree.rs" 779 8 781 9
  let%span span18 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span19 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span30 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span31 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span32 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span33 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span34 = "../red_black_tree.rs" 58 12 65 13
  let%span span35 = "../red_black_tree.rs" 177 20 177 54
  let%span span36 = "../red_black_tree.rs" 768 8 768 29
  let%span span37 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span38 = "../red_black_tree.rs" 70 4 71 93
  let%span span39 = "../red_black_tree.rs" 78 12 86 13
  let%span span40 = "../red_black_tree.rs" 91 15 91 35
  let%span span41 = "../red_black_tree.rs" 92 4 92 94
  let%span span42 = "../red_black_tree.rs" 98 12 107 13
  let%span span43 = "../red_black_tree.rs" 112 15 112 35
  let%span span44 = "../red_black_tree.rs" 113 4 113 80
  let%span span45 = "../red_black_tree.rs" 119 12 119 61
  let%span span46 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span47 = "" 0 0 0 0
  let%span span48 = "" 0 0 0 0
  let%span span49 = "" 0 0 0 0
  let%span span50 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span51 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span52 = "" 0 0 0 0
  let%span span53 = "../red_black_tree.rs" 263 16 263 48
  let%span span54 = "../red_black_tree.rs" 270 12 275 13
  let%span span55 = "../red_black_tree.rs" 648 15 648 43
  let%span span56 = "../red_black_tree.rs" 649 15 650 62
  let%span span57 = "../red_black_tree.rs" 659 27 659 31
  let%span span58 = "../red_black_tree.rs" 651 14 651 42
  let%span span59 = "../red_black_tree.rs" 652 14 652 50
  let%span span60 = "../red_black_tree.rs" 653 14 653 66
  let%span span61 = "../red_black_tree.rs" 654 4 654 104
  let%span span62 = "../red_black_tree.rs" 655 4 656 73
  let%span span63 = "../red_black_tree.rs" 657 14 657 39
  let%span span64 = "../red_black_tree.rs" 658 4 658 69
  let%span span65 = "../red_black_tree.rs" 659 36 659 42
  let%span span66 = "../red_black_tree.rs" 47 8 49 9
  let%span span67 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span68 = "../red_black_tree.rs" 419 15 419 19
  let%span span69 = "../red_black_tree.rs" 418 14 418 45
  
  predicate invariant'8 (self : v)
  
  predicate inv'14 (_1 : v)
  
  axiom inv'14 : forall x : v [inv'14 x] . inv'14 x  -> invariant'8 x
  
  predicate invariant'7 (self : k)
  
  predicate inv'13 (_1 : k)
  
  axiom inv'13 : forall x : k [inv'13 x] . inv'13 x  -> invariant'7 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'12 (_1 : Node'0.t_Node k v)
  
  axiom inv'12 [@rewrite] : forall x : Node'0.t_Node k v [inv'12 x] . inv'12 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'13 key /\ inv'14 val' /\ inv'5 right
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span6] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span7] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span10] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span9] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span11] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span12] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span14] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span16] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'6 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span17] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'11 (_1 : Map'0.t_Map k v)
  
  axiom inv'11 [@rewrite] : forall x : Map'0.t_Map k v [inv'11 x] . inv'11 x
  = (invariant'6 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'10 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate inv'9 (_1 : (k, v))
  
  axiom inv'9 [@rewrite] : forall x : (k, v) [inv'9 x] . inv'9 x = (let (a, b) = x in inv'13 a /\ inv'14 b)
  
  predicate invariant'5 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span18] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'8 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'8 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : Tree'0.t_Tree k v) =
    [%#span19] inv'5 self
  
  predicate inv'7 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'7 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'6 (_1 : Option'0.t_Option (k, v))
  
  axiom inv'6 [@rewrite] : forall x : Option'0.t_Option (k, v) [inv'6 x] . inv'6 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'9 a_0
    end
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span20] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span21] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span22] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span23] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span24] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span25] cmp_log'0 x y
  = o)  -> ([%#span26] cmp_log'0 y z = o)  -> ([%#span27] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span28] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span29] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span30] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span31] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span32] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'5 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span18] inv'3 self.current /\ inv'3 self.final
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'4 x] . inv'4 x = invariant'3 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span33] inv'12 self
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map k v)) =
    [%#span18] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'2 (_1 : borrowed (Map'0.t_Map k v))
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Map'0.t_Map k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span18] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use map.Const
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span34] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function shallow_model'2 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span35] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'1 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span36] shallow_model'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function shallow_model'0 (self : borrowed (Map'0.t_Map k v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v) =
    [%#span37] shallow_model'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span39] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span38] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span42] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span40] bst_invariant'0 self)
   -> ([%#span41] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span45] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span43] bst_invariant'0 self)
   -> ([%#span44] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'2 self) k = Option'0.C_Some v))
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span47] inv'10 self}
    {[@expl:precondition] [%#span46] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span48] inv'4 result}
      {[%#span46] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span49] inv'1 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span52] inv'10 result}
      {[%#span51] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span50] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span53] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span54] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  let rec delete_max_rec'0 (self:borrowed (Tree'0.t_Tree k v)) (return'  (ret:(k, v)))= {[@expl:precondition] [%#span57] inv'8 self}
    {[@expl:precondition] [%#span56] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#span55] internal_invariant'0 self.current}
    any
    [ return' (result:(k, v))-> {[%#span65] inv'9 result}
      {[%#span64] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#span63] color_invariant'0 self.final}
      {[%#span62] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#span61] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
       -> le_log'0 k (deep_model'0 (let (a, _) = result in a))}
      {[%#span60] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#span59] height'0 self.current = height'0 self.final}
      {[%#span58] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  predicate same_mappings'0 [#"../red_black_tree.rs" 46 4 46 43] (self : Tree'0.t_Tree k v) (o : Tree'0.t_Tree k v) =
    [%#span66] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v = has_mapping'0 o k v
  
  use prelude.prelude.Snapshot
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span67] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'5 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span68] inv'7 self}
    any [ return' (result:bool)-> {[%#span69] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'4 (self : borrowed (Map'0.t_Map k v)) =
    [%#span67] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map k v)) =
    resolve'4 _1
  
  predicate resolve'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span67] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max (self:borrowed (Map'0.t_Map k v)) (return'  (ret:Option'0.t_Option (k, v)))= {[%#sred_black_tree3] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_6 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s1)))
      | s1 = any
        [ br0 -> {_6.current = Option'0.C_None } (! bb8)
        | br1 (a:Node'0.t_Node k v)-> {_6.current = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb19 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node k v> {_6.current}
          (fun (r0'0:Node'0.t_Node k v) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _6) 1}
              (fun (_ret':borrowed (Node'0.t_Node k v)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_6 <- { _6 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_11 <- Color'0.C_Red ] s1
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 _11 rkey'0 rval'0 rright'0 ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#sred_black_tree1] same_mappings'0 (T_red_black_tree__Map.t_Map__0 (Snapshot.inner old_self).current) (T_red_black_tree__Map.t_Map__0 self.current)}
        s1
      | s1 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            {inv'5 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_16 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s2))
      | s2 = delete_max_rec'0 {_16} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
      
    | bb9 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) -> is_red'0 {r0'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_20 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_23 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_23} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_22} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_21 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {_21.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_21 <- { _21 with current = Node'0.C_Node rleft'0 _20 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _21} s2
      | s2 = -{resolve'2 _21}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_24 <- [%#sred_black_tree2] Snapshot.new () ] s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 =  [ &_0 <- Option'0.C_Some r ] s1 | s1 = bb17 ] 
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (k, v) = any_l ()
    | & self : borrowed (Map'0.t_Map k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (Map'0.t_Map k v)) = any_l ()
    | & _6 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _9 : bool = any_l ()
    | & _11 : Color'0.t_Color = any_l ()
    | & r : (k, v) = any_l ()
    | & _16 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : Color'0.t_Color = any_l ()
    | & _21 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _22 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _23 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & _24 : Snapshot.snap_ty () = any_l () ]
    
    [ return' (result:Option'0.t_Option (k, v))-> {[@expl:postcondition] [%#sred_black_tree5] inv'6 result}
      {[@expl:postcondition] [%#sred_black_tree4] match result with
        | Option'0.C_Some (k, v) -> Map.get (shallow_model'0 self) (deep_model'0 k) = Option'0.C_Some v
        /\ (forall k2 : t_DeepModelTy'0 . Map.get (shallow_model'0 self) k2 = Option'0.C_None
        \/ le_log'0 k2 (deep_model'0 k))
        /\ shallow_model'1 self.final = Map.set (shallow_model'0 self) (deep_model'0 k) (Option'0.C_None)
        | Option'0.C_None -> shallow_model'1 self.final = shallow_model'0 self
        /\ shallow_model'0 self = Const.const (Option'0.C_None)
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__delete_min [#"../red_black_tree.rs" 852 4 852 50] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 853 8 853 53
  let%span sred_black_tree1 = "../red_black_tree.rs" 852 27 852 31
  let%span sred_black_tree2 = "../red_black_tree.rs" 845 14 851 5
  let%span sred_black_tree3 = "../red_black_tree.rs" 852 36 852 50
  let%span span4 = "../red_black_tree.rs" 294 12 297 13
  let%span span5 = "../red_black_tree.rs" 318 20 318 102
  let%span span6 = "../red_black_tree.rs" 304 12 310 13
  let%span span7 = "../red_black_tree.rs" 331 14 331 25
  let%span span8 = "../red_black_tree.rs" 334 12 342 13
  let%span span9 = "../red_black_tree.rs" 375 20 375 61
  let%span span10 = "../red_black_tree.rs" 349 12 355 13
  let%span span11 = "../red_black_tree.rs" 37 12 41 13
  let%span span12 = "../red_black_tree.rs" 222 12 223 104
  let%span span13 = "../red_black_tree.rs" 242 12 248 13
  let%span span14 = "../red_black_tree.rs" 394 12 394 59
  let%span span15 = "../red_black_tree.rs" 779 8 781 9
  let%span span16 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span17 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span30 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span31 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span32 = "../red_black_tree.rs" 58 12 65 13
  let%span span33 = "../red_black_tree.rs" 177 20 177 54
  let%span span34 = "../red_black_tree.rs" 768 8 768 29
  let%span span35 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span36 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span37 = "" 0 0 0 0
  let%span span38 = "" 0 0 0 0
  let%span span39 = "" 0 0 0 0
  let%span span40 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span41 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span42 = "" 0 0 0 0
  let%span span43 = "../red_black_tree.rs" 263 16 263 48
  let%span span44 = "../red_black_tree.rs" 270 12 275 13
  let%span span45 = "../red_black_tree.rs" 676 15 676 43
  let%span span46 = "../red_black_tree.rs" 677 15 678 62
  let%span span47 = "../red_black_tree.rs" 687 27 687 31
  let%span span48 = "../red_black_tree.rs" 679 14 679 42
  let%span span49 = "../red_black_tree.rs" 680 14 680 50
  let%span span50 = "../red_black_tree.rs" 681 14 681 66
  let%span span51 = "../red_black_tree.rs" 682 4 682 104
  let%span span52 = "../red_black_tree.rs" 683 4 684 73
  let%span span53 = "../red_black_tree.rs" 685 14 685 39
  let%span span54 = "../red_black_tree.rs" 686 4 686 69
  let%span span55 = "../red_black_tree.rs" 687 36 687 42
  let%span span56 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span57 = "../red_black_tree.rs" 419 15 419 19
  let%span span58 = "../red_black_tree.rs" 418 14 418 45
  let%span span59 = "../red_black_tree.rs" 70 4 71 93
  let%span span60 = "../red_black_tree.rs" 78 12 86 13
  let%span span61 = "../red_black_tree.rs" 91 15 91 35
  let%span span62 = "../red_black_tree.rs" 92 4 92 94
  let%span span63 = "../red_black_tree.rs" 98 12 107 13
  let%span span64 = "../red_black_tree.rs" 112 15 112 35
  let%span span65 = "../red_black_tree.rs" 113 4 113 80
  let%span span66 = "../red_black_tree.rs" 119 12 119 61
  
  predicate invariant'8 (self : v)
  
  predicate inv'14 (_1 : v)
  
  axiom inv'14 : forall x : v [inv'14 x] . inv'14 x  -> invariant'8 x
  
  predicate invariant'7 (self : k)
  
  predicate inv'13 (_1 : k)
  
  axiom inv'13 : forall x : k [inv'13 x] . inv'13 x  -> invariant'7 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'12 (_1 : Node'0.t_Node k v)
  
  axiom inv'12 [@rewrite] : forall x : Node'0.t_Node k v [inv'12 x] . inv'12 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'13 key /\ inv'14 val' /\ inv'5 right
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span4] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span5] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span6] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span7] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span9] height'0 (T_red_black_tree__Node.t_Node__left self) = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span10] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span11] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span12] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span14] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'6 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span15] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'11 (_1 : Map'0.t_Map k v)
  
  axiom inv'11 [@rewrite] : forall x : Map'0.t_Map k v [inv'11 x] . inv'11 x
  = (invariant'6 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'10 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate inv'9 (_1 : (k, v))
  
  axiom inv'9 [@rewrite] : forall x : (k, v) [inv'9 x] . inv'9 x = (let (a, b) = x in inv'13 a /\ inv'14 b)
  
  predicate invariant'5 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span16] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'8 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'8 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : Tree'0.t_Tree k v) =
    [%#span17] inv'5 self
  
  predicate inv'7 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'7 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'6 (_1 : Option'0.t_Option (k, v))
  
  axiom inv'6 [@rewrite] : forall x : Option'0.t_Option (k, v) [inv'6 x] . inv'6 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'9 a_0
    end
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span18] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span21] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span22] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span23] cmp_log'0 x y
  = o)  -> ([%#span24] cmp_log'0 y z = o)  -> ([%#span25] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span26] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span27] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span28] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span29] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span30] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'5 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span16] inv'3 self.current /\ inv'3 self.final
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'4 x] . inv'4 x = invariant'3 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span31] inv'12 self
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map k v)) =
    [%#span16] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'2 (_1 : borrowed (Map'0.t_Map k v))
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Map'0.t_Map k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span16] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use map.Const
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function shallow_model'2 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span33] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'1 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span34] shallow_model'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function shallow_model'0 (self : borrowed (Map'0.t_Map k v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v) =
    [%#span35] shallow_model'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span37] inv'10 self}
    {[@expl:precondition] [%#span36] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span38] inv'4 result}
      {[%#span36] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span39] inv'1 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span42] inv'10 result}
      {[%#span41] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span40] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span43] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span44] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  let rec delete_min_rec'0 (self:borrowed (Tree'0.t_Tree k v)) (return'  (ret:(k, v)))= {[@expl:precondition] [%#span47] inv'8 self}
    {[@expl:precondition] [%#span46] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#span45] internal_invariant'0 self.current}
    any
    [ return' (result:(k, v))-> {[%#span55] inv'9 result}
      {[%#span54] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#span53] color_invariant'0 self.final}
      {[%#span52] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#span51] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'0 (let (a, _) = result in a)) k}
      {[%#span50] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#span49] height'0 self.current = height'0 self.final}
      {[%#span48] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span56] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'5 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span57] inv'7 self}
    any [ return' (result:bool)-> {[%#span58] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'4 (self : borrowed (Map'0.t_Map k v)) =
    [%#span56] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map k v)) =
    resolve'4 _1
  
  predicate resolve'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span56] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span60] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span59] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span63] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span61] bst_invariant'0 self)
   -> ([%#span62] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span66] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span64] bst_invariant'0 self)
   -> ([%#span65] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'2 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min (self:borrowed (Map'0.t_Map k v)) (return'  (ret:Option'0.t_Option (k, v)))= {[%#sred_black_tree1] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_6 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s1)))
      | s1 = any
        [ br0 -> {_6.current = Option'0.C_None } (! bb8)
        | br1 (a:Node'0.t_Node k v)-> {_6.current = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb18 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node k v> {_6.current}
          (fun (r0'0:Node'0.t_Node k v) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _6) 1}
              (fun (_ret':borrowed (Node'0.t_Node k v)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_6 <- { _6 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_11 <- Color'0.C_Red ] s1
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 _11 rkey'0 rval'0 rright'0 ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
      
    | bb7 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            {inv'5 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_14 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 = delete_min_rec'0 {_14} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) -> is_red'0 {r0'0} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_18 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_21 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_21} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_20 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_20} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_19 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {_19.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_19 <- { _19 with current = Node'0.C_Node rleft'0 _18 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _19} s2
      | s2 = -{resolve'2 _19}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- Option'0.C_Some r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (k, v) = any_l ()
    | & self : borrowed (Map'0.t_Map k v) = self
    | & _3 : Snapshot.snap_ty () = any_l ()
    | & _6 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _9 : bool = any_l ()
    | & _11 : Color'0.t_Color = any_l ()
    | & r : (k, v) = any_l ()
    | & _14 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _16 : bool = any_l ()
    | & _18 : Color'0.t_Color = any_l ()
    | & _19 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _20 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _21 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l () ]
    
    [ return' (result:Option'0.t_Option (k, v))-> {[@expl:postcondition] [%#sred_black_tree3] inv'6 result}
      {[@expl:postcondition] [%#sred_black_tree2] match result with
        | Option'0.C_Some (k, v) -> Map.get (shallow_model'0 self) (deep_model'0 k) = Option'0.C_Some v
        /\ (forall k2 : t_DeepModelTy'0 . Map.get (shallow_model'0 self) k2 = Option'0.C_None
        \/ le_log'0 (deep_model'0 k) k2)
        /\ shallow_model'1 self.final = Map.set (shallow_model'0 self) (deep_model'0 k) (Option'0.C_None)
        | Option'0.C_None -> shallow_model'1 self.final = shallow_model'0 self
        /\ shallow_model'0 self = Const.const (Option'0.C_None)
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__delete [#"../red_black_tree.rs" 875 4 875 55] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 876 8 876 53
  let%span sred_black_tree1 = "../red_black_tree.rs" 875 23 875 27
  let%span sred_black_tree2 = "../red_black_tree.rs" 875 29 875 32
  let%span sred_black_tree3 = "../red_black_tree.rs" 869 14 873 5
  let%span sred_black_tree4 = "../red_black_tree.rs" 874 14 874 59
  let%span sred_black_tree5 = "../red_black_tree.rs" 875 41 875 55
  let%span span6 = "../red_black_tree.rs" 294 12 297 13
  let%span span7 = "../red_black_tree.rs" 318 20 318 102
  let%span span8 = "../red_black_tree.rs" 304 12 310 13
  let%span span9 = "../red_black_tree.rs" 331 14 331 25
  let%span span10 = "../red_black_tree.rs" 334 12 342 13
  let%span span11 = "../red_black_tree.rs" 375 20 375 61
  let%span span12 = "../red_black_tree.rs" 349 12 355 13
  let%span span13 = "../red_black_tree.rs" 37 12 41 13
  let%span span14 = "../red_black_tree.rs" 222 12 223 104
  let%span span15 = "../red_black_tree.rs" 242 12 248 13
  let%span span16 = "../red_black_tree.rs" 394 12 394 59
  let%span span17 = "../red_black_tree.rs" 779 8 781 9
  let%span span18 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span19 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span20 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span21 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span30 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span31 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span32 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span33 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span34 = "../red_black_tree.rs" 58 12 65 13
  let%span span35 = "../red_black_tree.rs" 177 20 177 54
  let%span span36 = "../red_black_tree.rs" 768 8 768 29
  let%span span37 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span38 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span39 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span40 = "" 0 0 0 0
  let%span span41 = "" 0 0 0 0
  let%span span42 = "" 0 0 0 0
  let%span span43 = "../../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span span44 = "../../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span span45 = "" 0 0 0 0
  let%span span46 = "../red_black_tree.rs" 263 16 263 48
  let%span span47 = "../red_black_tree.rs" 270 12 275 13
  let%span span48 = "../red_black_tree.rs" 701 15 701 43
  let%span span49 = "../red_black_tree.rs" 702 15 703 62
  let%span span50 = "../red_black_tree.rs" 713 23 713 27
  let%span span51 = "../red_black_tree.rs" 713 29 713 32
  let%span span52 = "../red_black_tree.rs" 704 14 704 42
  let%span span53 = "../red_black_tree.rs" 705 14 705 50
  let%span span54 = "../red_black_tree.rs" 706 14 709 5
  let%span span55 = "../red_black_tree.rs" 710 4 710 129
  let%span span56 = "../red_black_tree.rs" 711 14 711 39
  let%span span57 = "../red_black_tree.rs" 712 4 712 69
  let%span span58 = "../red_black_tree.rs" 713 41 713 55
  let%span span59 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span60 = "../red_black_tree.rs" 419 15 419 19
  let%span span61 = "../red_black_tree.rs" 418 14 418 45
  let%span span62 = "../red_black_tree.rs" 70 4 71 93
  let%span span63 = "../red_black_tree.rs" 78 12 86 13
  let%span span64 = "../red_black_tree.rs" 91 15 91 35
  let%span span65 = "../red_black_tree.rs" 92 4 92 94
  let%span span66 = "../red_black_tree.rs" 98 12 107 13
  let%span span67 = "../red_black_tree.rs" 112 15 112 35
  let%span span68 = "../red_black_tree.rs" 113 4 113 80
  let%span span69 = "../red_black_tree.rs" 119 12 119 61
  
  predicate invariant'9 (self : v)
  
  predicate inv'15 (_1 : v)
  
  axiom inv'15 : forall x : v [inv'15 x] . inv'15 x  -> invariant'9 x
  
  predicate invariant'8 (self : k)
  
  predicate inv'14 (_1 : k)
  
  axiom inv'14 : forall x : k [inv'14 x] . inv'14 x  -> invariant'8 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'13 (_1 : Node'0.t_Node k v)
  
  axiom inv'13 [@rewrite] : forall x : Node'0.t_Node k v [inv'13 x] . inv'13 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span6] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span7] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span10] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span9] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span11] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span12] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span14] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span16] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'7 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span17] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'12 (_1 : Map'0.t_Map k v)
  
  axiom inv'12 [@rewrite] : forall x : Map'0.t_Map k v [inv'12 x] . inv'12 x
  = (invariant'7 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span18] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span21] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span22] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span23] cmp_log'0 x y
  = o)  -> ([%#span24] cmp_log'0 y z = o)  -> ([%#span25] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span26] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span27] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span28] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span29] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span30] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'11 (_1 : (k, v))
  
  axiom inv'11 [@rewrite] : forall x : (k, v) [inv'11 x] . inv'11 x = (let (a, b) = x in inv'14 a /\ inv'15 b)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node k v))
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node k v)))
  
  axiom inv'10 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node k v)) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant'6 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span31] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'9 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'9 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'5 (self : Tree'0.t_Tree k v) =
    [%#span32] inv'5 self
  
  predicate inv'8 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'8 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate inv'7 (_1 : Option'0.t_Option (k, v))
  
  axiom inv'7 [@rewrite] : forall x : Option'0.t_Option (k, v) [inv'7 x] . inv'7 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'11 a_0
    end
  
  predicate invariant'4 (self : k) =
    [%#span32] inv'14 self
  
  predicate inv'6 (_1 : k)
  
  axiom inv'6 [@rewrite] : forall x : k [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'5 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node k v)) =
    [%#span31] inv'3 self.current /\ inv'3 self.final
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'4 x] . inv'4 x = invariant'3 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span33] inv'13 self
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map k v)) =
    [%#span31] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'2 (_1 : borrowed (Map'0.t_Map k v))
  
  axiom inv'2 [@rewrite] : forall x : borrowed (Map'0.t_Map k v) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span31] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span34] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'2 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span35] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'1 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span36] shallow_model'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function shallow_model'0 (self : borrowed (Map'0.t_Map k v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v) =
    [%#span37] shallow_model'1 self.current
  
  function deep_model'1 (self : k) : t_DeepModelTy'0 =
    [%#span38] deep_model'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node k v))) (return'  (ret:borrowed (Node'0.t_Node k v)))= {[@expl:precondition] [%#span40] inv'10 self}
    {[@expl:precondition] [%#span39] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node k v))-> {[%#span41] inv'4 result}
      {[%#span39] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node k v))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node k v))))= {[@expl:precondition] [%#span42] inv'1 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node k v)))-> {[%#span45] inv'10 result}
      {[%#span44] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node k v) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#span43] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"../red_black_tree.rs" 262 0 262 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP
    
   =
    [%#span46] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span47] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  let rec delete_rec'0 (self:borrowed (Tree'0.t_Tree k v)) (key:k) (return'  (ret:Option'0.t_Option (k, v)))= {[@expl:precondition] [%#span51] inv'6 key}
    {[@expl:precondition] [%#span50] inv'9 self}
    {[@expl:precondition] [%#span49] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#span48] internal_invariant'0 self.current}
    any
    [ return' (result:Option'0.t_Option (k, v))-> {[%#span58] inv'7 result}
      {[%#span57] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#span56] color_invariant'0 self.final}
      {[%#span55] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self.final k v
      = (deep_model'1 key <> k /\ has_mapping'0 self.current k v)}
      {[%#span54] match result with
        | Option'0.C_None -> forall v : v . not has_mapping'0 self.current (deep_model'1 key) v
        | Option'0.C_Some (k, v) -> deep_model'1 key = deep_model'0 k /\ has_mapping'0 self.current (deep_model'0 k) v
        end}
      {[%#span53] height'0 self.current = height'0 self.final}
      {[%#span52] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node k v)) =
    [%#span59] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'5 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree k v) (return'  (ret:bool))= {[@expl:precondition] [%#span60] inv'8 self}
    any [ return' (result:bool)-> {[%#span61] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'4 (self : borrowed (Map'0.t_Map k v)) =
    [%#span59] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map k v)) =
    resolve'4 _1
  
  predicate resolve'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span59] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span63] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span62] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span66] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span64] bst_invariant'0 self)
   -> ([%#span65] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span69] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span67] bst_invariant'0 self)
   -> ([%#span68] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'2 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec delete (self:borrowed (Map'0.t_Map k v)) (key:k) (return'  (ret:Option'0.t_Option (k, v)))= {[%#sred_black_tree2] inv'6 key}
    {[%#sred_black_tree1] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node k v)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_8 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s1)))
      | s1 = any
        [ br0 -> {_8.current = Option'0.C_None } (! bb8)
        | br1 (a:Node'0.t_Node k v)-> {_8.current = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _8} s1
      | s1 = -{resolve'0 _8}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb17 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node k v> {_8.current}
          (fun (r0'0:Node'0.t_Node k v) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _8) 1}
              (fun (_ret':borrowed (Node'0.t_Node k v)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_8 <- { _8 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _8} s3
      | s3 = -{resolve'0 _8}- s4
      | s4 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_13 <- Color'0.C_Red ] s1
      | s1 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 _13 rkey'0 rval'0 rright'0 ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb7 ]
      
    | bb7 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            {inv'5 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree k v> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_16 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 = delete_rec'0 {_16} {key} (fun (_ret':Option'0.t_Option (k, v)) ->  [ &r <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) -> is_red'0 {r0'0} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_19 = false} (! bb14) | br1 -> {_19} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_21 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            Tree'0.t_Tree <k> <v> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_24 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_24} (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node k v))) ->  [ &_23 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_23} (fun (_ret':borrowed (Node'0.t_Node k v)) ->  [ &_22 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {_22.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_22 <- { _22 with current = Node'0.C_Node rleft'0 _21 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _22} s2
      | s2 = -{resolve'2 _22}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (k, v) = any_l ()
    | & self : borrowed (Map'0.t_Map k v) = self
    | & key : k = key
    | & _5 : Snapshot.snap_ty () = any_l ()
    | & _8 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _11 : bool = any_l ()
    | & _13 : Color'0.t_Color = any_l ()
    | & r : Option'0.t_Option (k, v) = any_l ()
    | & _16 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Color'0.t_Color = any_l ()
    | & _22 : borrowed (Node'0.t_Node k v) = any_l ()
    | & _23 : Option'0.t_Option (borrowed (Node'0.t_Node k v)) = any_l ()
    | & _24 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l () ]
    
    [ return' (result:Option'0.t_Option (k, v))-> {[@expl:postcondition] [%#sred_black_tree5] inv'7 result}
      {[@expl:postcondition] [%#sred_black_tree4] shallow_model'1 self.final
      = Map.set (shallow_model'0 self) (deep_model'1 key) (Option'0.C_None)}
      {[@expl:postcondition] [%#sred_black_tree3] match result with
        | Option'0.C_Some (k, v) -> deep_model'0 k = deep_model'1 key
        /\ Map.get (shallow_model'0 self) (deep_model'1 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'1 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__get [#"../red_black_tree.rs" 896 4 896 44] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 897 8 897 53
  let%span sred_black_tree1 = "../red_black_tree.rs" 900 20 900 29
  let%span sred_black_tree2 = "../red_black_tree.rs" 901 20 901 40
  let%span sred_black_tree3 = "../red_black_tree.rs" 900 8 900 31
  let%span sred_black_tree4 = "../red_black_tree.rs" 896 16 896 20
  let%span sred_black_tree5 = "../red_black_tree.rs" 896 22 896 25
  let%span sred_black_tree6 = "../red_black_tree.rs" 892 14 895 5
  let%span sred_black_tree7 = "../red_black_tree.rs" 896 34 896 44
  let%span span8 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span9 = "../red_black_tree.rs" 294 12 297 13
  let%span span10 = "../red_black_tree.rs" 318 20 318 102
  let%span span11 = "../red_black_tree.rs" 304 12 310 13
  let%span span12 = "../red_black_tree.rs" 331 14 331 25
  let%span span13 = "../red_black_tree.rs" 334 12 342 13
  let%span span14 = "../red_black_tree.rs" 375 20 375 61
  let%span span15 = "../red_black_tree.rs" 349 12 355 13
  let%span span16 = "../red_black_tree.rs" 37 12 41 13
  let%span span17 = "../red_black_tree.rs" 222 12 223 104
  let%span span18 = "../red_black_tree.rs" 242 12 248 13
  let%span span19 = "../red_black_tree.rs" 394 12 394 59
  let%span span20 = "../red_black_tree.rs" 779 8 781 9
  let%span span21 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span22 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span30 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span31 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span32 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span33 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span34 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span35 = "../red_black_tree.rs" 58 12 65 13
  let%span span36 = "../red_black_tree.rs" 177 20 177 54
  let%span span37 = "../red_black_tree.rs" 768 8 768 29
  let%span span38 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span39 = "" 0 0 0 0
  let%span span40 = "" 0 0 0 0
  let%span span41 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span span42 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span43 = "../red_black_tree.rs" 70 4 71 93
  let%span span44 = "../red_black_tree.rs" 78 12 86 13
  let%span span45 = "../red_black_tree.rs" 91 15 91 35
  let%span span46 = "../red_black_tree.rs" 92 4 92 94
  let%span span47 = "../red_black_tree.rs" 98 12 107 13
  let%span span48 = "../red_black_tree.rs" 112 15 112 35
  let%span span49 = "../red_black_tree.rs" 113 4 113 80
  let%span span50 = "../red_black_tree.rs" 119 12 119 61
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'9 (_1 : v)
  
  predicate inv'7 (_1 : k)
  
  predicate inv'5 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'11 (_1 : Node'0.t_Node k v)
  
  axiom inv'11 [@rewrite] : forall x : Node'0.t_Node k v [inv'11 x] . inv'11 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'7 key /\ inv'9 val' /\ inv'5 right
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'7 (self : Node'0.t_Node k v) =
    [%#span8] inv'11 self
  
  predicate inv'10 (_1 : Node'0.t_Node k v)
  
  axiom inv'10 [@rewrite] : forall x : Node'0.t_Node k v [inv'10 x] . inv'10 x = invariant'7 x
  
  predicate invariant'6 (self : v)
  
  axiom inv'9 : forall x : v [inv'9 x] . inv'9 x  -> invariant'6 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'8 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'8 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'8 x] . inv'8 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  predicate invariant'5 (self : k)
  
  axiom inv'7 : forall x : k [inv'7 x] . inv'7 x  -> invariant'5 x
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span9] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span10] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span11] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span12] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span14] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'1 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span17] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span19] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'4 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span20] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'6 (_1 : Map'0.t_Map k v)
  
  axiom inv'6 [@rewrite] : forall x : Map'0.t_Map k v [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  axiom inv'5 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'8 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : v) =
    [%#span21] inv'9 self
  
  predicate inv'4 (_1 : v)
  
  axiom inv'4 [@rewrite] : forall x : v [inv'4 x] . inv'4 x = invariant'3 x
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span23] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span24] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span25] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span26] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span27] cmp_log'0 x y
  = o)  -> ([%#span28] cmp_log'0 y z = o)  -> ([%#span29] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span30] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span31] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span32] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span33] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span34] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'3 (_1 : Option'0.t_Option v)
  
  axiom inv'3 [@rewrite] : forall x : Option'0.t_Option v [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant'2 (self : k) =
    [%#span21] inv'7 self
  
  predicate inv'2 (_1 : k)
  
  axiom inv'2 [@rewrite] : forall x : k [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : Map'0.t_Map k v) =
    [%#span21] inv'6 self
  
  predicate inv'1 (_1 : Map'0.t_Map k v)
  
  axiom inv'1 [@rewrite] : forall x : Map'0.t_Map k v [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 (self : Tree'0.t_Tree k v) =
    [%#span21] inv'5 self
  
  predicate inv'0 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'0 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'0 x] . inv'0 x = invariant'0 x
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span35] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'1 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span36] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'2 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span37] shallow_model'1 (T_red_black_tree__Map.t_Map__0 self)
  
  function shallow_model'0 (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v) =
    [%#span38] shallow_model'2 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] [%#span40] inv'2 other}
    {[@expl:precondition] [%#span39] inv'2 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#span41] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : k) : t_DeepModelTy'0 =
    [%#span42] deep_model'1 self
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span44] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span43] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span47] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span45] bst_invariant'0 self)
   -> ([%#span46] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span50] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span48] bst_invariant'0 self)
   -> ([%#span49] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'1 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec get (self:Map'0.t_Map k v) (key:k) (return'  (ret:Option'0.t_Option v))= {[%#sred_black_tree5] inv'2 key}
    {[%#sred_black_tree4] inv'1 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = Map'0.t_Map <k> <v> {self} (fun (r0'0:Tree'0.t_Tree k v) ->  [ &tree <- r0'0 ] s1) | s1 = bb2 ] 
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant] [%#sred_black_tree3] forall v : v . has_mapping'0 (T_red_black_tree__Map.t_Map__0 self) (deep_model'0 key) v
        = has_mapping'0 tree (deep_model'0 key) v}
        {[@expl:loop invariant] [%#sred_black_tree2] bst_invariant'0 tree}
        {[@expl:loop invariant] [%#sred_black_tree1] inv'0 tree}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 = Tree'0.t_Tree <k> <v> {tree}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->  [ &_13 <- rnode'0 ] s1)
          | s1 = any
            [ br0 -> {_13 = Option'0.C_None } (! bb14) | br1 (a:Node'0.t_Node k v)-> {_13 = Option'0.C_Some a} (! bb4) ]
             ]
          
        | bb4 = bb5
        | bb5 = s0
          [ s0 = Option'0.v_Some <Node'0.t_Node k v> {_13} (fun (r0'0:Node'0.t_Node k v) ->  [ &node <- r0'0 ] s1)
          | s1 = Node'0.t_Node <k> <v> {node}
              (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                 [ &_19 <- rkey'0 ] 
                s2)
          | s2 = cmp'0 {key} {_19} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_16 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = any
          [ br0 -> {_16 = Ordering'0.C_Less } (! bb8)
          | br1 -> {_16 = Ordering'0.C_Equal } (! bb9)
          | br2 -> {_16 = Ordering'0.C_Greater } (! bb10) ]
          
        | bb10 = s0
          [ s0 = Node'0.t_Node <k> <v> {node}
              (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                 [ &_27 <- rright'0 ] 
                s1)
          | s1 =  [ &tree <- _27 ] s2
          | s2 = bb13 ]
          
        | bb8 = bb11
        | bb11 = s0
          [ s0 = Node'0.t_Node <k> <v> {node}
              (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                 [ &_22 <- rleft'0 ] 
                s1)
          | s1 =  [ &tree <- _22 ] s2
          | s2 = bb13 ]
          
        | bb13 = bb2 ]
         ]
      
    | bb14 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb15 ] 
    | bb9 = bb12
    | bb12 = s0
      [ s0 = Node'0.t_Node <k> <v> {node}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
             [ &_25 <- rval'0 ] 
            s1)
      | s1 =  [ &_0 <- Option'0.C_Some _25 ] s2
      | s2 = bb15 ]
      
    | bb15 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option v = any_l ()
    | & self : Map'0.t_Map k v = self
    | & key : k = key
    | & _5 : Snapshot.snap_ty () = any_l ()
    | & tree : Tree'0.t_Tree k v = any_l ()
    | & _13 : Option'0.t_Option (Node'0.t_Node k v) = any_l ()
    | & node : Node'0.t_Node k v = any_l ()
    | & _16 : Ordering'0.t_Ordering = any_l ()
    | & _19 : k = any_l ()
    | & _22 : Tree'0.t_Tree k v = any_l ()
    | & _25 : v = any_l ()
    | & _27 : Tree'0.t_Tree k v = any_l () ]
    
    [ return' (result:Option'0.t_Option v)-> {[@expl:postcondition] [%#sred_black_tree7] inv'3 result}
      {[@expl:postcondition] [%#sred_black_tree6] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__get_mut [#"../red_black_tree.rs" 917 4 917 56] (* Map<K, V> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 918 8 918 53
  let%span sred_black_tree1 = "../red_black_tree.rs" 921 23 921 41
  let%span sred_black_tree2 = "../red_black_tree.rs" 923 20 923 29
  let%span sred_black_tree3 = "../red_black_tree.rs" 924 20 924 40
  let%span sred_black_tree4 = "../red_black_tree.rs" 925 20 925 43
  let%span sred_black_tree5 = "../red_black_tree.rs" 926 20 926 42
  let%span sred_black_tree6 = "../red_black_tree.rs" 923 8 923 31
  let%span sred_black_tree7 = "../red_black_tree.rs" 917 24 917 28
  let%span sred_black_tree8 = "../red_black_tree.rs" 917 30 917 33
  let%span sred_black_tree9 = "../red_black_tree.rs" 913 14 916 5
  let%span sred_black_tree10 = "../red_black_tree.rs" 917 42 917 56
  let%span span11 = "../red_black_tree.rs" 294 12 297 13
  let%span span12 = "../red_black_tree.rs" 318 20 318 102
  let%span span13 = "../red_black_tree.rs" 304 12 310 13
  let%span span14 = "../red_black_tree.rs" 331 14 331 25
  let%span span15 = "../red_black_tree.rs" 334 12 342 13
  let%span span16 = "../red_black_tree.rs" 375 20 375 61
  let%span span17 = "../red_black_tree.rs" 349 12 355 13
  let%span span18 = "../red_black_tree.rs" 37 12 41 13
  let%span span19 = "../red_black_tree.rs" 222 12 223 104
  let%span span20 = "../red_black_tree.rs" 242 12 248 13
  let%span span21 = "../red_black_tree.rs" 394 12 394 59
  let%span span22 = "../red_black_tree.rs" 779 8 781 9
  let%span span23 = "../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span span24 = "../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span span25 = "../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span span26 = "../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span span27 = "../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span span28 = "../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span span29 = "../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span span30 = "../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span span31 = "../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span span32 = "../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span span33 = "../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span span34 = "../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span span35 = "../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span span36 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span37 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span38 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span39 = "../red_black_tree.rs" 58 12 65 13
  let%span span40 = "../red_black_tree.rs" 177 20 177 54
  let%span span41 = "../red_black_tree.rs" 768 8 768 29
  let%span span42 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span43 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span44 = "" 0 0 0 0
  let%span span45 = "" 0 0 0 0
  let%span span46 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span span47 = "../red_black_tree.rs" 270 12 275 13
  let%span span48 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span49 = "../red_black_tree.rs" 70 4 71 93
  let%span span50 = "../red_black_tree.rs" 78 12 86 13
  let%span span51 = "../red_black_tree.rs" 91 15 91 35
  let%span span52 = "../red_black_tree.rs" 92 4 92 94
  let%span span53 = "../red_black_tree.rs" 98 12 107 13
  let%span span54 = "../red_black_tree.rs" 112 15 112 35
  let%span span55 = "../red_black_tree.rs" 113 4 113 80
  let%span span56 = "../red_black_tree.rs" 119 12 119 61
  
  predicate invariant'9 (self : k)
  
  predicate inv'13 (_1 : k)
  
  axiom inv'13 : forall x : k [inv'13 x] . inv'13 x  -> invariant'9 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'0 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span11] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span12] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span14] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span16] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span17] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'1 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span19] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span21] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'8 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span22] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'12 (_1 : Map'0.t_Map k v)
  
  axiom inv'12 [@rewrite] : forall x : Map'0.t_Map k v [inv'12 x] . inv'12 x
  = (invariant'8 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'0 a_0
    end)
  
  predicate inv'6 (_1 : v)
  
  predicate inv'11 (_1 : Node'0.t_Node k v)
  
  axiom inv'11 [@rewrite] : forall x : Node'0.t_Node k v [inv'11 x] . inv'11 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'0 left /\ inv'13 key /\ inv'6 val' /\ inv'0 right
    end
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span23] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span24] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#span25] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#span26] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#span27] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#span28] cmp_log'0 x y
  = o)  -> ([%#span29] cmp_log'0 y z = o)  -> ([%#span30] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#span31] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span32] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span33] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span34] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#span35] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use prelude.prelude.Borrow
  
  predicate inv'7 (_1 : borrowed v)
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed v))
  
  axiom inv'10 [@rewrite] : forall x : Option'0.t_Option (borrowed v) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'7 a_0
    end
  
  predicate invariant'7 (self : k) =
    [%#span36] inv'13 self
  
  predicate inv'9 (_1 : k)
  
  axiom inv'9 [@rewrite] : forall x : k [inv'9 x] . inv'9 x = invariant'7 x
  
  predicate invariant'6 (self : borrowed (Map'0.t_Map k v)) =
    [%#span37] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'8 (_1 : borrowed (Map'0.t_Map k v))
  
  axiom inv'8 [@rewrite] : forall x : borrowed (Map'0.t_Map k v) [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate invariant'5 (self : borrowed v) =
    [%#span37] inv'6 self.current /\ inv'6 self.final
  
  axiom inv'7 [@rewrite] : forall x : borrowed v [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : v)
  
  axiom inv'6 : forall x : v [inv'6 x] . inv'6 x  -> invariant'4 x
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  predicate invariant'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span37] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v)))
  
  axiom inv'5 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node k v)) [inv'5 x] . inv'5 x
  = invariant'3 x
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node k v)) =
    [%#span37] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node k v))
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node k v) [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'1 (self : Node'0.t_Node k v) =
    [%#span38] inv'11 self
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'1 x
  
  axiom inv'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  predicate invariant'0 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span37] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Tree'0.t_Tree k v))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Tree'0.t_Tree k v) [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv'0 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'0 x] . inv'0 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span39] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'2 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span40] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'1 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span41] shallow_model'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function shallow_model'0 (self : borrowed (Map'0.t_Map k v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v) =
    [%#span42] shallow_model'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'9 (self : borrowed (Map'0.t_Map k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'4 (_1 : borrowed (Map'0.t_Map k v)) =
    resolve'9 _1
  
  predicate resolve'8 (self : borrowed v) =
    [%#span43] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed v) =
    resolve'8 _1
  
  predicate resolve'7 (self : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    [%#span43] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node k v))) =
    resolve'7 _1
  
  predicate resolve'6 (self : borrowed (Node'0.t_Node k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node k v)) =
    resolve'6 _1
  
  predicate resolve'5 (self : borrowed (Tree'0.t_Tree k v)) =
    [%#span43] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Tree'0.t_Tree k v)) =
    resolve'5 _1
  
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] [%#span45] inv'9 other}
    {[@expl:precondition] [%#span44] inv'9 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#span46] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"../red_black_tree.rs" 268 4 268 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree k v) =
    [%#span47] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node k v . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  use prelude.prelude.Snapshot
  
  function deep_model'0 (self : k) : t_DeepModelTy'0 =
    [%#span48] deep_model'1 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 72 4 76 5] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span50] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . [%#span49] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : v . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 93 4 95 33] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span53] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree k v, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v), k : t_DeepModelTy'0 . ([%#span51] bst_invariant'0 self)
   -> ([%#span52] forall v : v . has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"../red_black_tree.rs" 114 4 116 33] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) : ()
    
   =
    [%#span56] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree k v, k : t_DeepModelTy'0 . ([%#span54] bst_invariant'0 self)
   -> ([%#span55] forall v : v . has_mapping'0 self k v = (Map.get (shallow_model'2 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec get_mut (self:borrowed (Map'0.t_Map k v)) (key:k) (return'  (ret:Option'0.t_Option (borrowed v)))= {[%#sred_black_tree8] inv'9 key}
    {[%#sred_black_tree7] inv'8 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <k> <v> {self.current}
          (fun (r0'0:Tree'0.t_Tree k v) ->
            {inv'0 r0'0}
            Borrow.borrow_final <Tree'0.t_Tree k v> {r0'0} {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &tree <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 =  [ &old_tree <- [%#sred_black_tree1] Snapshot.new tree ] s2
      | s2 = bb2 ]
      
    | bb2 = bb3
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant] [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : v . has_mapping'0 tree.current k v
        = has_mapping'0 tree.final k v
         -> has_mapping'0 (Snapshot.inner old_tree).current k v = has_mapping'0 (Snapshot.inner old_tree).final k v}
        {[@expl:loop invariant] [%#sred_black_tree6] match_t'0 (CP'0.C_CPL (color'0 tree.current)) tree.final
         -> match_t'0 (CP'0.C_CPL (Color'0.C_Black)) (Snapshot.inner old_tree).final}
        {[@expl:loop invariant] [%#sred_black_tree6] height'0 tree.current = height'0 tree.final
        /\ height_invariant'0 tree.final  -> height_invariant'0 (Snapshot.inner old_tree).final}
        {[@expl:loop invariant] [%#sred_black_tree6] (forall k : t_DeepModelTy'0, v : v . k = deep_model'0 key
        \/ has_mapping'0 tree.current k v = has_mapping'0 tree.final k v)
         -> bst_invariant'0 tree.final  -> bst_invariant'0 (Snapshot.inner old_tree).final}
        {[@expl:loop invariant] [%#sred_black_tree6] forall v : v . has_mapping'0 tree.current (deep_model'0 key) v
        = has_mapping'0 (Snapshot.inner old_tree).current (deep_model'0 key) v}
        {[@expl:loop invariant] [%#sred_black_tree6] forall v : v . has_mapping'0 tree.final (deep_model'0 key) v
        = has_mapping'0 (Snapshot.inner old_tree).final (deep_model'0 key) v}
        {[@expl:loop invariant] [%#sred_black_tree5] color_invariant'0 tree.current}
        {[@expl:loop invariant] [%#sred_black_tree4] height_invariant'0 tree.current}
        {[@expl:loop invariant] [%#sred_black_tree3] bst_invariant'0 tree.current}
        {[@expl:loop invariant] [%#sred_black_tree2] inv'1 tree}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = Tree'0.t_Tree <k> <v> {tree.current}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node k v)) ->
                {inv'2 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.get_id tree) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node k v))) ->
                     [ &_22 <- _ret' ] 
                    -{inv'2 _ret'.final}-
                     [ &tree <- { tree with current = Tree'0.C_Tree _ret'.final ; } ] 
                    s1))
          | s1 = any
            [ br0 -> {_22.current = Option'0.C_None } (! bb15)
            | br1 (a:Node'0.t_Node k v)-> {_22.current = Option'0.C_Some a} (! bb5) ]
             ]
          
        | bb5 = bb6
        | bb6 = s0
          [ s0 = Option'0.v_Some <Node'0.t_Node k v> {_22.current}
              (fun (r0'0:Node'0.t_Node k v) ->
                {inv'3 r0'0}
                Borrow.borrow_final <Node'0.t_Node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _22) 1}
                  (fun (_ret':borrowed (Node'0.t_Node k v)) ->
                     [ &node <- _ret' ] 
                    -{inv'3 _ret'.final}-
                     [ &_22 <- { _22 with current = Option'0.C_Some _ret'.final ; } ] 
                    s1))
          | s1 = Node'0.t_Node <k> <v> {node.current}
              (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                 [ &_28 <- rkey'0 ] 
                s2)
          | s2 = cmp'0 {key} {_28} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_25 <- _ret' ] s3)
          | s3 = bb7 ]
          
        | bb7 = any
          [ br0 -> {_25 = Ordering'0.C_Less } (! bb9)
          | br1 -> {_25 = Ordering'0.C_Equal } (! bb10)
          | br2 -> {_25 = Ordering'0.C_Greater } (! bb11) ]
          
        | bb11 = s0
          [ s0 = Node'0.t_Node <k> <v> {node.current}
              (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                {inv'0 rright'0}
                Borrow.borrow_final <Tree'0.t_Tree k v> {rright'0} {Borrow.inherit_id (Borrow.get_id node) 5}
                  (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                     [ &_36 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                    s1))
          | s1 = {inv'0 _36.current}
            Borrow.borrow_final <Tree'0.t_Tree k v> {_36.current} {Borrow.get_id _36}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_35 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_36 <- { _36 with current = _ret'.final ; } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'1 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _35 ] s5
          | s5 = {[@expl:type invariant] inv'1 _36} s6
          | s6 = -{resolve'0 _36}- s7
          | s7 = bb14 ]
          
        | bb9 = bb12
        | bb12 = s0
          [ s0 = Node'0.t_Node <k> <v> {node.current}
              (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
                {inv'0 rleft'0}
                Borrow.borrow_final <Tree'0.t_Tree k v> {rleft'0} {Borrow.inherit_id (Borrow.get_id node) 1}
                  (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                     [ &_31 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                    s1))
          | s1 = {inv'0 _31.current}
            Borrow.borrow_final <Tree'0.t_Tree k v> {_31.current} {Borrow.get_id _31}
              (fun (_ret':borrowed (Tree'0.t_Tree k v)) ->
                 [ &_30 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_31 <- { _31 with current = _ret'.final ; } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'1 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _30 ] s5
          | s5 = {[@expl:type invariant] inv'1 _31} s6
          | s6 = -{resolve'0 _31}- s7
          | s7 = bb14 ]
          
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'4 node} s1
          | s1 = -{resolve'1 node}- s2
          | s2 = {[@expl:type invariant] inv'5 _22} s3
          | s3 = -{resolve'2 _22}- s4
          | s4 = bb3 ]
           ]
         ]
      
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'5 _22} s1
      | s1 = -{resolve'2 _22}- s2
      | s2 =  [ &_0 <- Option'0.C_None ] s3
      | s3 = bb16 ]
      
    | bb10 = bb13
    | bb13 = s0
      [ s0 = Node'0.t_Node <k> <v> {node.current}
          (fun (rleft'0:Tree'0.t_Tree k v) (rcolor'0:Color'0.t_Color) (rkey'0:k) (rval'0:v) (rright'0:Tree'0.t_Tree k v) ->
            {inv'6 rval'0}
            Borrow.borrow_final <v> {rval'0} {Borrow.inherit_id (Borrow.get_id node) 4}
              (fun (_ret':borrowed v) ->
                 [ &_34 <- _ret' ] 
                -{inv'6 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 _ret'.final rright'0 ; } ] 
                s1))
      | s1 = {inv'6 _34.current}
        Borrow.borrow_final <v> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed v) ->
             [ &_33 <- _ret' ] 
            -{inv'6 _ret'.final}-
             [ &_34 <- { _34 with current = _ret'.final ; } ] 
            s2)
      | s2 =  [ &_0 <- Option'0.C_Some _33 ] s3
      | s3 = {[@expl:type invariant] inv'7 _34} s4
      | s4 = -{resolve'3 _34}- s5
      | s5 = {[@expl:type invariant] inv'4 node} s6
      | s6 = -{resolve'1 node}- s7
      | s7 = {[@expl:type invariant] inv'5 _22} s8
      | s8 = -{resolve'2 _22}- s9
      | s9 = bb16 ]
      
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'1 tree} s1
      | s1 = -{resolve'0 tree}- s2
      | s2 = {[@expl:type invariant] inv'8 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = return' {_0} ]
       ]
    )
    [ & _0 : Option'0.t_Option (borrowed v) = any_l ()
    | & self : borrowed (Map'0.t_Map k v) = self
    | & key : k = key
    | & _5 : Snapshot.snap_ty () = any_l ()
    | & tree : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & old_tree : Snapshot.snap_ty (borrowed (Tree'0.t_Tree k v)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node k v)) = any_l ()
    | & node : borrowed (Node'0.t_Node k v) = any_l ()
    | & _25 : Ordering'0.t_Ordering = any_l ()
    | & _28 : k = any_l ()
    | & _30 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _31 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _33 : borrowed v = any_l ()
    | & _34 : borrowed v = any_l ()
    | & _35 : borrowed (Tree'0.t_Tree k v) = any_l ()
    | & _36 : borrowed (Tree'0.t_Tree k v) = any_l () ]
    
    [ return' (result:Option'0.t_Option (borrowed v))-> {[@expl:postcondition] [%#sred_black_tree10] inv'10 result}
      {[@expl:postcondition] [%#sred_black_tree9] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some (v.current)
        /\ shallow_model'1 self.final = Map.set (shallow_model'0 self) (deep_model'0 key) (Option'0.C_Some (v.final))
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        /\ shallow_model'1 self.final = shallow_model'0 self
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi11959472507597060150 [#"../red_black_tree.rs" 12 9 12 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree0 = "../red_black_tree.rs" 12 9 12 14
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use T_red_black_tree__Color as Color'0
  
  predicate inv'1 (_1 : Color'0.t_Color)
  
  axiom inv'1 [@rewrite] : forall x : Color'0.t_Color [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Color'0.t_Color) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Color'0.t_Color)
  
  axiom inv'0 [@rewrite] : forall x : Color'0.t_Color [inv'0 x] . inv'0 x = true
  
  goal clone'_refn : [%#sred_black_tree0] forall self : Color'0.t_Color . inv'0 self
   -> (forall result : Color'0.t_Color . result = self  -> inv'1 result /\ result = self)
end
module M_red_black_tree__qyi8854539789375892259 [#"../red_black_tree.rs" 12 16 12 20] (* <Color as std::marker::Copy> *)
  
end
module M_red_black_tree__qyi7393660211899550390 [#"../red_black_tree.rs" 159 0 159 49] (* <Node<K, V> as creusot_contracts::ShallowModel> *)
  type k
  
  type v
end
module M_red_black_tree__qyi10212607617007459931 [#"../red_black_tree.rs" 171 0 171 49] (* <Tree<K, V> as creusot_contracts::ShallowModel> *)
  type k
  
  type v
end
module M_red_black_tree__qyi5974114958194732512 [#"../red_black_tree.rs" 762 0 762 48] (* <Map<K, V> as creusot_contracts::ShallowModel> *)
  type k
  
  type v
end
module M_red_black_tree__qyi14787627995992352676 [#"../red_black_tree.rs" 181 0 181 44] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 194 4 194 31
  let%span span1 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "../red_black_tree.rs" 37 12 41 13
  let%span span4 = "../red_black_tree.rs" 185 8 187 9
  let%span span5 = "../red_black_tree.rs" 142 4 143 86
  let%span span6 = "../red_black_tree.rs" 145 8 148 9
  let%span span7 = "../red_black_tree.rs" 201 8 203 9
  let%span span8 = "../../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span span9 = "../../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  
  predicate invariant'3 (self : v)
  
  predicate inv'6 (_1 : v)
  
  axiom inv'6 : forall x : v [inv'6 x] . inv'6 x  -> invariant'3 x
  
  predicate invariant'2 (self : k)
  
  predicate inv'5 (_1 : k)
  
  axiom inv'5 : forall x : k [inv'5 x] . inv'5 x  -> invariant'2 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'1 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node k v)
  
  axiom inv'4 [@rewrite] : forall x : Node'0.t_Node k v [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'1 left /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'1 (self : Node'0.t_Node k v) =
    [%#span1] inv'4 self
  
  predicate inv'3 (_1 : Node'0.t_Node k v)
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node k v [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv'1 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'1 x] . inv'1 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Tree'0.t_Tree k v) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'0 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 (_1 : v)
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span3] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'0 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span4] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span6] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span5] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'8 [#"../red_black_tree.rs" 200 4 200 28] (self : Node'0.t_Node k v) =
    [%#span7] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'7 (_1 : Node'0.t_Node k v) =
    resolve'8 _1
  
  predicate resolve'6 (self : Node'0.t_Node k v) =
    [%#span8] resolve'7 self
  
  predicate resolve'5 (_1 : Node'0.t_Node k v) =
    resolve'6 _1
  
  predicate resolve'3 (self : Option'0.t_Option (Node'0.t_Node k v)) =
    [%#span9] match self with
      | Option'0.C_Some x -> resolve'5 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option (Node'0.t_Node k v)) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Tree'0.t_Tree k v) =
    match x with
      | Tree'0.C_Tree a -> resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#sred_black_tree0] forall self : Tree'0.t_Tree k v . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi16896830124134315792 [#"../red_black_tree.rs" 197 0 197 44] (* <Node<K, V> as creusot_contracts::Resolve> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 210 4 210 31
  let%span span1 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "../red_black_tree.rs" 37 12 41 13
  let%span span4 = "../red_black_tree.rs" 142 4 143 86
  let%span span5 = "../red_black_tree.rs" 145 8 148 9
  let%span span6 = "../red_black_tree.rs" 201 8 203 9
  let%span span7 = "../red_black_tree.rs" 185 8 187 9
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node k v)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'3 (self : Node'0.t_Node k v) =
    [%#span1] inv'1 self
  
  predicate inv'6 (_1 : Node'0.t_Node k v)
  
  axiom inv'6 [@rewrite] : forall x : Node'0.t_Node k v [inv'6 x] . inv'6 x = invariant'3 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'5 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  predicate invariant'2 (self : v)
  
  predicate inv'4 (_1 : v)
  
  axiom inv'4 : forall x : v [inv'4 x] . inv'4 x  -> invariant'2 x
  
  predicate invariant'1 (self : k)
  
  predicate inv'3 (_1 : k)
  
  axiom inv'3 : forall x : k [inv'3 x] . inv'3 x  -> invariant'1 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree k v)
  
  axiom inv'2 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'5 node
    end
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node k v [inv'1 x] . inv'1 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'3 key /\ inv'4 val' /\ inv'2 right
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_Node k v) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Node'0.t_Node k v)
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node k v [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 (_1 : v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span3] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 144 4 144 57] (self : Node'0.t_Node k v) (k : t_DeepModelTy'0) (v : v)
    
   =
    [%#span5] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node k v, k : t_DeepModelTy'0, v : v . [%#span4] forall node : Node'0.t_Node k v . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'0 [#"../red_black_tree.rs" 200 4 200 28] (self : Node'0.t_Node k v) =
    [%#span6] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Color as Color'0
  
  predicate resolve'4 (_1 : Color'0.t_Color) =
    true
  
  predicate resolve'3 (_1 : k)
  
  predicate resolve'5 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span7] forall k : t_DeepModelTy'0, v : v . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree k v) =
    resolve'5 _1
  
  predicate structural_resolve'0 (x : Node'0.t_Node k v) =
    match x with
      | Node'0.C_Node a b c d e -> resolve'1 e /\ resolve'2 d /\ resolve'3 c /\ resolve'4 b /\ resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#sred_black_tree0] forall self : Node'0.t_Node k v . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi10312951825188598006 [#"../red_black_tree.rs" 785 0 787 29] (* <Map<K, V> as creusot_contracts::Resolve> *)
  type k
  
  type v
  
  let%span sred_black_tree0 = "../red_black_tree.rs" 800 4 800 31
  let%span span1 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span span2 = "../red_black_tree.rs" 294 12 297 13
  let%span span3 = "../red_black_tree.rs" 318 20 318 102
  let%span span4 = "../red_black_tree.rs" 304 12 310 13
  let%span span5 = "../red_black_tree.rs" 331 14 331 25
  let%span span6 = "../red_black_tree.rs" 334 12 342 13
  let%span span7 = "../red_black_tree.rs" 375 20 375 61
  let%span span8 = "../red_black_tree.rs" 349 12 355 13
  let%span span9 = "../red_black_tree.rs" 37 12 41 13
  let%span span10 = "../red_black_tree.rs" 222 12 223 104
  let%span span11 = "../red_black_tree.rs" 242 12 248 13
  let%span span12 = "../red_black_tree.rs" 394 12 394 59
  let%span span13 = "../red_black_tree.rs" 779 8 781 9
  let%span span14 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span15 = "../../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span span16 = "../red_black_tree.rs" 58 12 65 13
  let%span span17 = "../red_black_tree.rs" 177 20 177 54
  let%span span18 = "../red_black_tree.rs" 768 8 768 29
  let%span span19 = "../red_black_tree.rs" 792 8 792 70
  let%span span20 = "../red_black_tree.rs" 185 8 187 9
  
  predicate invariant'4 (self : v)
  
  predicate inv'7 (_1 : v)
  
  axiom inv'7 : forall x : v [inv'7 x] . inv'7 x  -> invariant'4 x
  
  predicate invariant'3 (self : k)
  
  predicate inv'6 (_1 : k)
  
  axiom inv'6 : forall x : k [inv'6 x] . inv'6 x  -> invariant'3 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree k v)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'5 (_1 : Node'0.t_Node k v)
  
  axiom inv'5 [@rewrite] : forall x : Node'0.t_Node k v [inv'5 x] . inv'5 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'6 key /\ inv'7 val' /\ inv'2 right
    end
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'2 (self : Node'0.t_Node k v) =
    [%#span1] inv'5 self
  
  predicate inv'4 (_1 : Node'0.t_Node k v)
  
  axiom inv'4 [@rewrite] : forall x : Node'0.t_Node k v [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (Node'0.t_Node k v))
  
  axiom inv'3 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node k v) [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  axiom inv'2 [@rewrite] : forall x : Tree'0.t_Tree k v [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'3 node
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"../red_black_tree.rs" 292 4 292 27] (self : Tree'0.t_Tree k v) : Color'0.t_Color =
    [%#span2] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 317 4 317 41] (self : Node'0.t_Node k v) =
    [%#span3] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"../red_black_tree.rs" 302 4 302 36] (self : Tree'0.t_Tree k v) =
    [%#span4] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"../red_black_tree.rs" 332 4 332 26] (self : Tree'0.t_Tree k v) : int =
    [%#span6] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree k v . [%#span5] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 374 4 374 42] (self : Node'0.t_Node k v) =
    [%#span7] height'0 (T_red_black_tree__Node.t_Node__left self) = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"../red_black_tree.rs" 347 4 347 37] (self : Tree'0.t_Tree k v) =
    [%#span8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_core__cmp__Ordering as Ordering'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : k) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"../red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree k v) (k : t_DeepModelTy'0) (v : v)
   =
    [%#span9] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 220 4 220 39] (self : Node'0.t_Node k v) =
    [%#span10] (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : v . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"../red_black_tree.rs" 240 4 240 34] (self : Tree'0.t_Tree k v) =
    [%#span11] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"../red_black_tree.rs" 392 4 392 39] (self : Tree'0.t_Tree k v) =
    [%#span12] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'1 [#"../red_black_tree.rs" 778 4 778 30] (self : Map'0.t_Map k v) =
    [%#span13] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'1 (_1 : Map'0.t_Map k v)
  
  axiom inv'1 [@rewrite] : forall x : Map'0.t_Map k v [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'2 a_0
    end)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Map'0.t_Map k v) =
    [%#span14] inv'1 self
  
  predicate inv'0 (_1 : Map'0.t_Map k v)
  
  axiom inv'0 [@rewrite] : forall x : Map'0.t_Map k v [inv'0 x] . inv'0 x = invariant'0 x
  
  use map.Map
  
  predicate resolve'5 (_1 : v)
  
  predicate resolve'4 (self : Option'0.t_Option v) =
    [%#span15] match self with
      | Option'0.C_Some x -> resolve'5 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'2 (_1 : Option'0.t_Option v) =
    resolve'4 _1
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"../red_black_tree.rs" 53 4 56 47] (self : Tree'0.t_Tree k v) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option v)) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function shallow_model'1 [#"../red_black_tree.rs" 176 4 176 50] (self : Tree'0.t_Tree k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span17] model_acc'0 self (Const.const (Option'0.C_None))
  
  function shallow_model'0 [#"../red_black_tree.rs" 767 4 767 50] (self : Map'0.t_Map k v) : Map.map t_DeepModelTy'0 (Option'0.t_Option v)
    
   =
    [%#span18] shallow_model'1 (T_red_black_tree__Map.t_Map__0 self)
  
  predicate resolve'0 [#"../red_black_tree.rs" 791 4 791 28] (self : Map'0.t_Map k v) =
    [%#span19] forall k : t_DeepModelTy'0 . resolve'2 (Map.get (shallow_model'0 self) k)
  
  predicate resolve'3 [#"../red_black_tree.rs" 184 4 184 28] (self : Tree'0.t_Tree k v) =
    [%#span20] forall k : t_DeepModelTy'0, v : v . has_mapping'0 self k v  -> resolve'5 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree k v) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Map'0.t_Map k v) =
    match x with
      | Map'0.C_Map a -> resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#sred_black_tree0] forall self : Map'0.t_Map k v . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi4285627418884817745 [#"../red_black_tree.rs" 772 0 774 29] (* <Map<K, V> as creusot_contracts::Invariant> *)
  type k
  
  type v
end
